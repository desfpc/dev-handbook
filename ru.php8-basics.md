[📚 Содержание](README.ru.md)

- [Типы данных и сравнения](#типы-данных-и-сравнения)
- [Ссылки и переменные переменных](#ссылки-и-переменные-переменных)
- [Строки и кодировки](#строки-и-кодировки)
- [Области видимости и замыкания](#области-видимости-и-замыкания)
- [Массивы и их особенности](#массивы-и-их-особенности)
- [Обработка ошибок: от @ к исключениям](#обработка-ошибок)
- [Рекурсия и итерация](#рекурсия-и-итерация)
- [Классы и объекты](#классы-и-объекты)
- [Управление памятью](#управление-памятью)
- [Типичные вопросы на собеседованиях](#типичные-вопросы-на-собеседованиях)

# 🐘 Основы PHP: ключевые концепции и подводные камни

Эта глава — компактный обзор основ PHP, ориентированный на джуниоров, которые формируют базу знаний, и опытных разработчиков, готовящихся к собеседованиям или желающих освежить знания. Здесь мы разберём типичные ошибки, нюансы языка и вопросы, которые часто встречаются на технических интервью. Без лишней «воды», только практичные примеры и подводные камни.

## 📚 Содержание


---

## Типы данных и сравнения

PHP — динамически типизированный язык, но его поведение с типами данных часто вызывает путаницу. Основные типы: `int`, `float`, `string`, `bool`, `array`, `object`, `null`.

### Подводные камни
- **Сравнение с `==` и `===`**: Оператор `==` приводит типы перед сравнением, что может привести к неожиданным результатам. Используйте `===` для строгого сравнения (значение и тип).
  ```php
  $a = "10";
  $b = 10;
  var_dump($a == $b);  // bool(true) — приводит строку к числу
  var_dump($a === $b); // bool(false) — разные типы
  ```
- **Числа и строки**: Приведение строк к числам может быть неочевидным.
  ```php
  $str = "123abc";
  var_dump((int)$str); // int(123) — PHP игнорирует нечисловые символы
  ```

### Логические значения

Функции `empty()`, `isset()`, `is_null()`, оператор `=== null`, и `array_key_exists()` используются для проверки переменных и элементов массивов, но их поведение имеет важные различия, которые часто приводят к ошибкам.

- **`empty($var)`**: Проверяет, является ли переменная «пустой». Считает «пустыми» значения: `false`, `0`, `0.0`, `""`, `"0"`, `null`, `[]`, и неинициализированные переменные.
- **`isset($var)`**: Проверяет, существует ли переменная и не равна ли она `null`.
- **`is_null($var)`**: Проверяет, равна ли переменная строго `null`. Выбрасывает `E_WARNING`, если переменная не определена.
- **`=== null`**: Строгое сравнение с `null`, проверяет, является ли значение переменной `null`. Также выбрасывает `E_WARNING` для неопределённой переменной.
- **`array_key_exists($key, $array)`**: Проверяет, существует ли указанный ключ в массиве.

#### Пример с переменной
```php
$var = "0";
$nullVar = null;
$unsetVar;

var_dump(empty($var));        // bool(true) — строка "0" считается пустой
var_dump(isset($var));        // bool(true) — переменная существует
var_dump(is_null($var));      // bool(false) — переменная не null
var_dump($var === null);      // bool(false) — переменная не null
var_dump(empty($nullVar));    // bool(true) — null считается пустым
var_dump(isset($nullVar));    // bool(false) — null не проходит проверку isset
var_dump(is_null($nullVar));  // bool(true) — явно null
var_dump($nullVar === null);  // bool(true) — явно null
var_dump(empty($unsetVar));   // bool(true) — неинициализированная переменная пуста
var_dump(isset($unsetVar));   // bool(false) — неинициализированная переменная не существует
var_dump(is_null($unsetVar)); // bool(true) — неинициализированная переменная считается null
var_dump($unsetVar === null); // bool(true) — неинициализированная переменная равна null
```

#### Пример с массивом
```php
$array = ["key" => "value", "empty" => "", "zero" => 0, "null" => null];

var_dump(array_key_exists("key", $array));   // bool(true) — ключ существует
var_dump(array_key_exists("missing", $array)); // bool(false) — ключ отсутствует
var_dump(isset($array["null"]));       // bool(false) — значение null не проходит isset
var_dump(empty($array["zero"]));       // bool(true) — значение 0 считается пустым
var_dump(is_null($array["null"]));     // bool(true) — значение явно null
var_dump($array["null"] === null);     // bool(true) — значение равно null
```

#### Подводные камни
- `empty()` возвращает `true` для строки `"0"`, что может быть неожиданным, если `"0"` — валидное значение.
- `isset()` возвращает `false` для `null`, даже если ключ существует в массиве.
- `is_null()` и `=== null` ведут себя одинаково для существующих переменных, но оба вызывают `E_WARNING` для неопределённых переменных, в отличие от `isset()`.
  ```php
  var_dump(is_null($undefined)); // bool(true) + E_WARNING
  var_dump($undefined === null); // bool(true) + E_WARNING
  var_dump(isset($undefined));   // bool(false) — без предупреждения
  ```
- `array_key_exists()` проверяет только наличие ключа, игнорируя значение, в отличие от `isset()`.

#### Сравнение `is_null()` и `=== null`
- **Поведение**: Оба проверяют, является ли значение строго `null`. Для определённых переменных они идентичны по результату.
  ```php
  $var = null;
  var_dump(is_null($var));  // bool(true)
  var_dump($var === null);  // bool(true)
  ```
- **Различия**:
  - `is_null()` — функция, явно предназначенная для проверки `null`. Более читаема в сложных условиях.
  - `=== null` — оператор сравнения, менее очевидный в коде, особенно при сравнении с другими значениями.
  - Для неопределённых переменных оба вызывают `E_WARNING`, но `isset()` позволяет избежать предупреждения.
- **Когда использовать**:
  - Используйте `is_null()` для явной проверки на `null` (например, для читаемости).
  - Используйте `=== null` в сложных условиях:
    ```php
    if ($var === null || $var === 0) {
        echo "Переменная либо null, либо 0";
    }
    ```
  - Для проверки существования перед проверкой на `null` используйте `isset()`:
    ```php
    if (isset($var) && $var === null) {
        echo "Переменная существует и равна null";
    }
    ```

#### Производительность
Тестирование показывает, что `isset()` — самая быстрая функция для проверки существования переменной или ключа, так как выполняется на уровне движка PHP. `=== null` быстрее, чем `is_null()`, так как это оператор. `is_null()` медленнее из-за накладных расходов на вызов функции. `empty()` медленнее всех, так как проверяет существование и «пустоту». `array_key_exists()` — самый медленный, так как работает с хэш-таблицей массива.

**Пример теста производительности** (на 1 млн итераций, PHP 8.1):
```php
$var = null;
$array = ["key" => "value"];
$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    isset($var);
}
echo "isset: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    $var === null;
}
echo "=== null: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    is_null($var);
}
echo "is_null: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    empty($var);
}
echo "empty: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    array_key_exists("key", $array);
}
echo "array_key_exists: " . (microtime(true) - $start) . " seconds\n";
```
**Примерные результаты** (зависят от окружения):
- `isset`: ~0.03 сек
- `=== null`: ~0.04 сек
- `is_null`: ~0.05 сек
- `empty`: ~0.07 сек
- `array_key_exists`: ~0.09 сек

**Совет**: Используйте `isset()` для проверки существования переменных или ключей, чтобы избежать предупреждений. Для проверки на `null` предпочтите `=== null` в простых случаях из-за скорости, а `is_null()` — для читаемости. Избегайте `empty()`, если строка `"0"` — валидное значение. На собеседованиях часто спрашивают разницу между `is_null()`, `=== null`, и `isset()`, а также их влияние на производительность.

---

## Ссылки и переменные переменных

Ссылки и переменные переменных в PHP — мощные, но неочевидные инструменты, которые могут упростить код или усложнить отладку. В PHP 8 ссылки (`&`) используются для передачи данных по ссылке, а переменные переменных (`$$var`) позволяют динамически обращаться к переменным. Этот раздел разбирает их применение, подводные камни и добавляет слабые ссылки (`WeakReference`) как современный инструмент управления памятью.

### Ссылки в PHP 8

Ссылки позволяют нескольким переменным указывать на одну и ту же область памяти. Оператор `&` используется для создания ссылок при передаче в функции, в циклах или при присваивании.

#### Использование ссылок
- **Передача в функции**: Позволяет функции изменять исходную переменную.
  ```php
  function increment(&$number) {
      $number++;
  }
  $value = 5;
  increment($value);
  var_dump($value); // int(6)
  ```
- **Циклы `foreach`**: Ссылка на элемент массива позволяет изменять массив напрямую.
  ```php
  $array = [1, 2, 3];
  foreach ($array as &$item) {
      $item *= 2;
  }
  var_dump($array); // [2, 4, 6]
  ```
- **Присваивание по ссылке**: Создаёт псевдоним для переменной.
  ```php
  $a = 10;
  $b = &$a;
  $b = 20;
  var_dump($a); // int(20) — $a и $b указывают на одну память
  ```

#### Работа с объектами
В PHP 8 объекты по умолчанию передаются по ссылке (точнее, по дескриптору объекта), поэтому `&` для объектов в функциях не требуется.
```php
class Counter {
    public int $value = 0;
}

function incrementCounter(Counter $counter) {
    $counter->value++;
}

$counter = new Counter();
incrementCounter($counter);
var_dump($counter->value); // int(1)
```


**Лайфхак**: Избегайте `&` для объектов, так как это избыточно и может запутать код. Однако `&` полезен, если нужно заменить объект целиком.
```php
function replaceCounter(&$counter) {
    $counter = new Counter();
}

$counter = new Counter();
replaceCounter($counter);
var_dump($counter); // object(Counter)#2 — новый объект
```

#### Клонирование объекта

```php
$c = $a; // новый объект не создается; $c - это ссылка на тот же объект, что и $a
$b = clone $a; // создаётся копия объекта $a
```

Можно определить `__clone()` для модификации поведения.

#### Подводные камни
- **Ошибки в `foreach`**: После цикла с `&` переменная `$item` остаётся ссылкой, что может привести к неожиданным изменениям.
  ```php
  $array = [1, 2, 3];
  foreach ($array as &$item) {
      $item *= 2;
  }
  $item = 10; // Изменяет последний элемент массива!
  var_dump($array); // [2, 4, 10]
  ```
  **Решение**: Сбрасывайте ссылку с помощью `unset($item)` после цикла.
  ```php
  foreach ($array as &$item) {
      $item *= 2;
  }
  unset($item); // Безопасно
  ```
- **Копии вместо ссылок**: Присваивание без `&` создаёт копию, что может быть неожиданным.
  ```php
  $a = [1, 2];
  $b = $a; // Копия
  $b[0] = 10;
  var_dump($a); // [1, 2] — $a не изменился
  ```
- **Производительность**: Ссылки могут замедлить выполнение из-за механизма copy-on-write в PHP.
  ```php
  $array = range(1, 1000);
  $start = microtime(true);
  foreach ($array as &$item) {
      $item += 1;
  }
  echo "With reference: " . (microtime(true) - $start) . " seconds\n";

  $array = range(1, 1000);
  $start = microtime(true);
  foreach ($array as $key => $item) {
      $array[$key] += 1;
  }
  echo "Without reference: " . (microtime(true) - $start) . " seconds\n";
  ```
  **Результаты** (PHP 8.1, ориентировочно):
  - `With reference`: ~0.0003 сек
  - `Without reference`: ~0.0002 сек

**Лайфхак**: Используйте ссылки только при необходимости (например, для изменения данных). Для больших массивов без `&` может быть быстрее из-за оптимизации copy-on-write.

### Переменные переменных

Переменные переменных (`$$var`) позволяют обращаться к переменной, имя которой хранится в другой переменной. Это полезно для динамического доступа к данным.

#### Пример использования
```php
$name = "price";
$$name = 100; // Создаёт переменную $price
var_dump($price); // int(100)
```
**Практический пример**: Динамическая обработка конфигурации.
```php
$config = ['user' => 'Alice', 'role' => 'admin'];
foreach ($config as $key => $value) {
    $$key = $value;
}
var_dump($user, $role); // string(5) "Alice", string(5) "admin"
```

#### Подводные камни
- **Читаемость**: Код с `$$var` трудно читать и отлаживать.
  ```php
  $var = "x";
  $x = 10;
  $$var = 20;
  var_dump($x); // int(20) — неочевидно
  ```
- **Безопасность**: Динамическое создание переменных может привести к уязвимостям, если имена берутся из пользовательского ввода.
  ```php
  $var = $_GET['name']; // Опасно!
  $$var = 1; // Может перезаписать критические переменные
  ```
  **Решение**: Используйте массивы вместо переменных переменных.
  ```php
  $config = [];
  $config[$_GET['name']] = 1; // Безопаснее
  ```
- **Производительность**: Доступ через `$$var` медленнее, чем через массив.
  ```php
  $iterations = 1000000;
  $name = "price";

  $start = microtime(true);
  for ($i = 0; $i < $iterations; $i++) {
      $$name = 100;
  }
  echo "Variable variable: " . (microtime(true) - $start) . " seconds\n";

  $start = microtime(true);
  for ($i = 0; $i < $iterations; $i++) {
      $data[$name] = 100;
  }
  echo "Array access: " . (microtime(true) - $start) . " seconds\n";
  ```
  **Результаты** (PHP 8.1, ориентировочно):
  - `Variable variable`: ~0.05 сек
  - `Array access`: ~0.03 сек

**Лайфхак**: Заменяйте переменные переменных ассоциативными массивами для лучшей читаемости и безопасности. Используйте `$$var` только в редких случаях, например, для динамической конфигурации.

### Слабые ссылки (WeakReference)

В PHP 7.4+ (и PHP 8) появились слабые ссылки (`WeakReference`), которые позволяют ссылаться на объект без предотвращения его удаления сборщиком мусора. Это полезно для кэширования или управления памятью.

#### Пример использования
```php
$object = new stdClass();
$weakRef = WeakReference::create($object);
var_dump($weakRef->get()); // object(stdClass)#1

unset($object); // Объект может быть удалён
var_dump($weakRef->get()); // NULL — объект удалён
```

**Практический пример**: Кэширование объектов.
```php
class Cache {
    private array $items = [];

    public function set($key, $object) {
        $this->items[$key] = WeakReference::create($object);
    }

    public function get($key) {
        return isset($this->items[$key]) ? $this->items[$key]->get() : null;
    }
}

$cache = new Cache();
$object = new stdClass();
$cache->set('key', $object);
var_dump($cache->get('key')); // object(stdClass)#1
unset($object);
var_dump($cache->get('key')); // NULL
```

#### Подводные камни
- **Ограниченное применение**: `WeakReference` не предотвращает удаление объекта, что может быть неожиданным.
- **Совместимость**: Поддерживается только в PHP 7.4+, не работает с примитивными типами.
- **Производительность**: Создание `WeakReference` добавляет накладные расходы.
  ```php
  $iterations = 1000000;

  $start = microtime(true);
  for ($i = 0; $i < $iterations; $i++) {
      $obj = new stdClass();
      $ref = &$obj;
  }
  echo "Regular reference: " . (microtime(true) - $start) . " seconds\n";

  $start = microtime(true);
  for ($i = 0; $i < $iterations; $i++) {
      $obj = new stdClass();
      $weakRef = WeakReference::create($obj);
  }
  echo "WeakReference: " . (microtime(true) - $start) . " seconds\n";
  ```
  **Результаты** (PHP 8.1, ориентировочно):
  - `Regular reference`: ~0.07 сек
  - `WeakReference`: ~0.12 сек

**Лайфхак**: Используйте `WeakReference` для кэширования объектов, которые могут быть удалены, чтобы избежать утечек памяти. Например, в системах событий или DI-контейнерах.

### Советы
- Используйте `&` для изменения данных в функциях или циклах, но избегайте для объектов, так как они передаются по дескриптору.
- Сбрасывайте ссылки после `foreach` с `unset()` для избежания ошибок.
- Заменяйте переменные переменных (`$$var`) массивами для безопасности и скорости.
- Применяйте `WeakReference` для кэшей или временных ссылок на объекты.
- На собеседованиях часто спрашивают:
  - Разницу между передачей по значению и по ссылке.
  - Почему `foreach` с `&` может привести к ошибкам.
  - Как работают переменные переменных и их риски.
  - Когда использовать `WeakReference` и чем оно отличается от обычной ссылки.

**Ресурсы**:
- [Документация PHP: Ссылки](https://www.php.net/manual/ru/language.references.php)
- [Документация PHP: WeakReference](https://www.php.net/manual/ru/class.weakreference.php)
- [3v4l.org](https://3v4l.org/) — для тестирования кода

---

## Строки и кодировки

Строки в PHP — один из основных типов данных, но работа с ними, особенно с многобайтными кодировками (UTF-8), полна подводных камней. Этот раздел разбирает функции для работы со строками, кодировки и типичные ошибки.

### Ключевые моменты
- **Однобайтные vs многобайтные строки**: PHP по умолчанию считает строки однобайтными, что ломает работу с UTF-8. Используйте функции `mb_*` для корректной обработки.
  ```php
  $str = "Привет";
  var_dump(strlen($str));     // int(12) — считает байты
  var_dump(mb_strlen($str)); // int(6) — считает символы (UTF-8)
  ```
- **Кодировка по умолчанию**: PHP 8 использует UTF-8 для новых функций, но старые (например, `htmlspecialchars()`) требуют явного указания кодировки.
  ```php
  $str = "Тест <b>";
  echo htmlspecialchars($str, ENT_QUOTES, 'UTF-8'); // Тест &lt;b&gt;
  ```

### Типичные ошибки
- **Обрезка строк**: `substr()` режет по байтам, что может «сломать» UTF-8 символы.
  ```php
  $str = "Привет";
  var_dump(substr($str, 0, 3));     // string(3) "При" — обрезает некорректно
  var_dump(mb_substr($str, 0, 3)); // string(6) "При" — корректно
  ```
- **Регулярные выражения**: Без флага `u` (`PCRE_UTF8`) Unicode-символы обрабатываются неправильно.
  ```php
  $str = "Привет, мир!";
  var_dump(preg_match('/\w+/', $str));      // int(0) — не распознаёт кириллицу
  var_dump(preg_match('/\w+/u', $str));    // int(1) — корректно с UTF-8
  ```
- **Кодировка ввода/вывода**: Если сервер или БД используют разные кодировки (например, Windows-1251), вывод может быть искажён.
  ```php
  $str = mb_convert_encoding("Привет", "Windows-1251", "UTF-8");
  var_dump($str); // строка в Windows-1251
  ```

### Производительность
Функции `mb_*` медленнее стандартных (`strlen`, `substr`) из-за обработки многобайтных символов.
```php
$str = "Привет, мир!";
$iterations = 1000000;

$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    strlen($str);
}
echo "strlen: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    mb_strlen($str);
}
echo "mb_strlen: " . (microtime(true) - $start) . " seconds\n";
```
**Результаты** (PHP 8.1, ориентировочно):
- `strlen`: ~0.03 сек
- `mb_strlen`: ~0.08 сек

### Подводные камни
- **Неправильная кодировка**: Если не указать UTF-8 в `htmlspecialchars()` или `json_encode()`, результат может быть некорректным.
  ```php
  $data = ["text" => "Привет"];
  echo json_encode($data, JSON_UNESCAPED_UNICODE); // {"text":"Привет"}
  echo json_encode($data); // {"text":"\u041f\u0440\u0438\u0432\u0435\u0442"}
  ```
- **Производительность**: Частое использование `mb_*` в циклах замедляет код. Кэшируйте результаты, если возможно.
- **Сравнение строк**: Функции `strcmp()` или `===` не учитывают регистр или нормализацию Unicode.
  ```php
  $str1 = "ё";
  $str2 = "ё"; // Комбинированный символ
  var_dump($str1 === $str2); // bool(false)
  ```

### Лайфхаки
- Всегда используйте `mb_*` для работы с UTF-8 строками (включите расширение `mbstring`).
- Указывайте кодировку явно в функциях вроде `htmlspecialchars()` и `json_encode()`.
- Для сложных операций с Unicode используйте библиотеки, такие как `intl` (например, `Normalizer`).

### Советы для собеседований
- Часто спрашивают:
  - Разницу между `strlen()` и `mb_strlen()`.
  - Как обрабатывать UTF-8 в регулярных выражениях.
  - Почему `substr()` может «сломать» строку.
- Подготовьтесь объяснить, как кодировки влияют на ввод/вывод и как избежать «кракозябр» в веб-приложениях.

**Ресурсы**:
- [Документация PHP: Многобайтные строки](https://www.php.net/manual/ru/book.mbstring.php)
- [Документация PHP: Intl](https://www.php.net/manual/ru/book.intl.php)

---

## Области видимости и замыкания

PHP имеет три основные области видимости: глобальная, локальная и статическая. Неправильное понимание областей приводит к ошибкам, особенно в замыканиях.

### Ключевые моменты
- **Глобальная область**: Переменные, объявленные вне функций, не доступны внутри без `global` или `$GLOBALS`.
  ```php
  $x = 10;
  function test() {
      global $x;
      echo $x; // 10
  }
  test();
  ```
- **Статические переменные**: Сохраняют значение между вызовами функции.
  ```php
  function counter() {
      static $count = 0;
      return ++$count;
  }
  echo counter(); // 1
  echo counter(); // 2
  ```
- **Замыкания**: Анонимные функции могут захватывать переменные с помощью `use`, но по умолчанию они передаются по значению.
  ```php
  $x = 10;
  $closure = function() use ($x) {
      return $x;
  };
  $x = 20;
  echo $closure(); // 10 — захвачено исходное значение
  ```

### Подводные камни
- Изменение захваченной переменной в замыкании требует передачи по ссылке (`use (&$x)`).
  ```php
  $x = 10;
  $closure = function() use (&$x) {
      $x++;
  };
  $closure();
  echo $x; // 11
  ```

**Совет**: Избегайте `global`, используйте параметры функций или замыкания для передачи данных. На собеседованиях часто спрашивают, как работает `use` в замыканиях.

---

## Массивы и их особенности

Массивы в PHP — мощный инструмент, поддерживающий числовые и ассоциативные ключи, но их поведение может быть неочевидным. Неправильное использование массивов или функций для работы с ними часто приводит к ошибкам, особенно у начинающих разработчиков. Этот раздел разбирает типичные ошибки и функции, в которых путаются, а также даёт советы для собеседований.

### Ключевые моменты
- **Числовые и ассоциативные массивы**: PHP автоматически присваивает числовые ключи, но их можно смешивать со строковыми, что иногда вызывает путаницу.
  ```php
  $array = [1, 2, "key" => "value"];
  var_dump($array); // [0 => 1, 1 => 2, "key" => "value"]
  ```
- **Операторы объединения**: Оператор `+` и функция `array_merge()` ведут себя по-разному.
  ```php
  $a = ["a" => 1, "b" => 2];
  $b = ["b" => 3, "c" => 4];
  $result = $a + $b; // ["a" => 1, "b" => 2, "c" => 4] — сохраняет первые значения ключей
  $merged = array_merge($a, $b); // ["a" => 1, "b" => 3, "c" => 4] — перезаписывает ключи
  ```
- **Удаление элементов**: `unset()` не переиндексирует числовые ключи, что может нарушить логику.
  ```php
  $array = [0, 1, 2];
  unset($array[1]);
  var_dump($array); // [0 => 0, 2 => 2]
  var_dump(array_values($array)); // [0 => 0, 1 => 2] — переиндексация
  ```

### Типичные ошибки
- **Смешивание ключей**: Числовые и строковые ключи могут конфликтовать, особенно если строка интерпретируется как число.
  ```php
  $array = [10, "1" => 20];
  var_dump($array); // [0 => 10, 1 => 20] — ключ "1" интерпретируется как числовой
  ```
- **Неверное использование `unset` в циклах**: Удаление элементов в цикле `foreach` может привести к пропуску элементов.
  ```php
  $array = [1, 2, 3];
  foreach ($array as $key => $value) {
      unset($array[$key]);
  }
  var_dump($array); // [] — массив очищен
  ```
  **Ошибка**: Если использовать `foreach` с изменением массива, итератор может пропустить элементы. Используйте `array_filter` или цикл `for` для безопасного удаления.
  ```php
  $array = [1, 2, 3];
  $array = array_filter($array, fn($value) => $value != 2);
  var_dump($array); // [0 => 1, 2 => 3]
  ```
- **Неправильная проверка существования**: Использование `isset()` вместо `array_key_exists()` для проверки ключей с `null` значением.
  ```php
  $array = ["key" => null];
  var_dump(isset($array["key"])); // bool(false) — не проходит для null
  var_dump(array_key_exists("key", $array)); // bool(true) — ключ существует
  ```

### Функции, в которых путаются
- **`array_merge()`**: Объединяет массивы, перезаписывая значения одинаковых ключей. Для числовых ключей создаёт новые индексы.
  ```php
  $a = [1, 2];
  $b = [3, 4];
  var_dump(array_merge($a, $b)); // [0 => 1, 1 => 2, 2 => 3, 3 => 4]
  ```
- **`array_column()`**: Извлекает значения определённого ключа из массива записей. Полезно для обработки данных из БД.
  ```php
  $users = [
      ["id" => 1, "name" => "Alice"],
      ["id" => 2, "name" => "Bob"]
  ];
  $names = array_column($users, "name");
  var_dump($names); // ["Alice", "Bob"]
  ```
  **Подводный камень**: Если ключ отсутствует в записи, `array_column()` пропустит эту запись.
  ```php
  $users = [
      ["id" => 1],
      ["name" => "Bob"]
  ];
  var_dump(array_column($users, "id")); // [1] — запись без ключа "id" игнорируется
  ```
- **`array_combine()`**: Создаёт массив, используя один массив как ключи, а другой как значения.
  ```php
  $keys = ["id1", "id2"];
  $values = ["Alice", "Bob"];
  var_dump(array_combine($keys, $values)); // ["id1" => "Alice", "id2" => "Bob"]
  ```
  **Пример с БД**: Создание словаря ID → имя из результата запроса.
  ```php
  $users = [
      ["id" => 1, "name" => "Alice"],
      ["id" => 2, "name" => "Bob"]
  ];
  $idToName = array_combine(
      array_column($users, "id"),
      array_column($users, "name")
  );
  var_dump($idToName); // [1 => "Alice", 2 => "Bob"]
  ```
  **Подводный камень**: Оба массива должны иметь одинаковую длину, иначе ошибка.
  ```php
  $keys = ["a", "b"];
  $values = [1];
  var_dump(array_combine($keys, $values)); // ValueError (PHP 8+)
  ```
- **`array_key_exists()`**: Проверяет наличие ключа в массиве, даже если значение `null`.
  ```php
  $array = ["key" => null];
  var_dump(array_key_exists("key", $array)); // bool(true)
  ```
  **Подводный камень**: Медленнее, чем `isset()`, но необходим для проверки ключей с `null`.
- **`in_array()`**: Проверяет наличие значения в массиве.
  ```php
  $array = [1, "2", 3];
  var_dump(in_array("2", $array)); // bool(true) — приводит типы
  var_dump(in_array("2", $array, true)); // bool(true) — строгое сравнение
  ```
  **Подводный камень**: Без третьего параметра (`strict = true`) выполняется приведение типов, что может дать ложный результат.
  ```php
  var_dump(in_array("2", [2])); // bool(true) — приводит строку к числу
  ```
- **`array_search()`**: Возвращает ключ первого найденного значения или `false`, если значение не найдено.
  ```php
  $array = ["a" => 1, "b" => 2, "c" => 1];
  var_dump(array_search(1, $array)); // string(1) "a" — первый ключ
  ```
  **Подводный камень**: Без строгого сравнения (`strict = true`) может вернуть неверный ключ из-за приведения типов.
  ```php
  var_dump(array_search("2", [2])); // int(0) — приводит типы
  var_dump(array_search("2", [2], true)); // bool(false) — строгое сравнение
  ```
- **`array_map()`**: Применяет функцию к каждому элементу массива, возвращая новый массив.
  ```php
  $array = [1, 2, 3];
  $result = array_map(fn($value) => $value * 2, $array);
  var_dump($result); // [2, 4, 6]
  ```
  **Сравнение с `foreach`**:
  - `array_map()`: Функциональный стиль, возвращает новый массив, не изменяет исходный.
    ```php
    $array = [1, 2, 3];
    $result = array_map(fn($value) => $value + 1, $array);
    var_dump($result); // [2, 3, 4]
    var_dump($array); // [1, 2, 3] — исходный массив неизменён
    ```
  - `foreach`: Императивный стиль, может изменять исходный массив.
    ```php
    $array = [1, 2, 3];
    foreach ($array as &$value) {
        $value += 1;
    }
    var_dump($array); // [2, 3, 4] — исходный массив изменён
    ```
  **Подводный камень**: `array_map()` не может изменять исходный массив напрямую и требует возврата нового массива. `foreach` удобнее для модификации массива, но менее читаем в функциональном стиле.
  **Производительность**: `array_map()` обычно медленнее `foreach` из-за вызова функции для каждого элемента.
  > Кроме того, `foreach` — проще для чтения. Так что лично я не люблю `array_map`, хотя встречал отдельных деятелей, которые на код-ревью просили переписать foreach на array_map. Осуждаю, не будьте такими!

### Подводные камни
- **Пустота массива**: `empty($array)` возвращает `true` только для пустого массива, но `[0]` или `[""]` не считаются пустыми.
  ```php
  $array = [0];
  var_dump(empty($array)); // bool(false)
  ```
- **Передача по ссылке**: Изменение массива в функции требует явной передачи по ссылке.
  ```php
  function modifyArray($array) {
      $array[] = 4; // Не изменяет исходный массив
  }
  $array = [1, 2, 3];
  modifyArray($array);
  var_dump($array); // [1, 2, 3]
  ```
  **Решение**: Используйте `&` для передачи по ссылке.
  ```php
  function modifyArray(&$array) {
      $array[] = 4;
  }
  modifyArray($array);
  var_dump($array); // [1, 2, 3, 4]
  ```
- **Автоинкремент ключей**: PHP автоматически увеличивает числовые ключи, что может нарушить логику.
  ```php
  $array = [0 => "a", 2 => "b"];
  $array[] = "c";
  var_dump($array); // [0 => "a", 2 => "b", 3 => "c"] — следующий числовой ключ
  ```

### Производительность
Функции работы с массивами, такие как `array_key_exists()`, `in_array()`, `array_search()`, и `array_map()`, медленнее, чем `isset()`, из-за работы с хэш-таблицами. `array_merge()` быстрее, чем `+`, для больших массивов. `array_map()` медленнее `foreach` из-за накладных расходов на вызов функции.

**Пример теста производительности** (на 1 млн итераций, PHP 8.1):
```php
$array = ["key" => "value"];
$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    isset($array["key"]);
}
echo "isset: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    array_key_exists("key", $array);
}
echo "array_key_exists: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    in_array("value", $array);
}
echo "in_array: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    array_search("value", $array);
}
echo "array_search: " . (microtime(true) - $start) . " seconds\n";

$array = [1, 2, 3];
$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    array_map(fn($value) => $value * 2, $array);
}
echo "array_map: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    $result = [];
    foreach ($array as $value) {
        $result[] = $value * 2;
    }
}
echo "foreach: " . (microtime(true) - $start) . " seconds\n";
```
**Примерные результаты** (зависят от окружения):
- `isset`: ~0.03 сек
- `array_key_exists`: ~0.09 сек
- `in_array`: ~0.11 сек
- `array_search`: ~0.12 сек
- `array_map`: ~0.15 сек
- `foreach`: ~0.10 сек

### Советы
- Используйте `array_merge()` вместо `+` для объединения массивов, чтобы избежать потери данных.
- Проверяйте ключи с `array_key_exists()`, если значение может быть `null`; для скорости используйте `isset()`.
- Для поиска значений указывайте `strict = true` в `in_array()` и `array_search()`, чтобы избежать приведения типов.
- Используйте `array_map()` для функционального стиля, а `foreach` — для изменения массива или большей скорости.
- На собеседованиях часто спрашивают:
  - Разницу между `array_merge()` и `+`.
  - Почему `unset` в `foreach` опасен.
  - Разницу между `isset()` и `array_key_exists()`.
  - Как работают `array_map()` и `array_column()`.

### Сортировка массивов и поиск

PHP предоставляет набор встроенных функций для сортировки массивов, которые оптимизированы на уровне движка и используют алгоритм introsort (гибрид быстрой сортировки, пирамидальной сортировки и сортировки вставками). Писать собственную сортировку редко оправдано, но полезно понимать, как работают стандартные функции и их производительность.

#### Стандартные функции сортировки
- **`sort()`**: Сортирует массив по значениям, сбрасывая ключи (числовая индексация с 0).
  ```php
  $array = [3, 1, 2];
  sort($array);
  var_dump($array); // [0 => 1, 1 => 2, 2 => 3]
  ```
- **`rsort()`**: Сортирует по значениям в обратном порядке, сбрасывая ключи.
  ```php
  $array = [3, 1, 2];
  rsort($array);
  var_dump($array); // [0 => 3, 1 => 2, 2 => 1]
  ```
- **`asort()`**: Сортирует по значениям, сохраняя ключи.
  ```php
  $array = ["b" => 2, "a" => 1];
  asort($array);
  var_dump($array); // ["a" => 1, "b" => 2]
  ```
- **`arsort()`**: Сортирует по значениям в обратном порядке, сохраняя ключи.
  ```php
  $array = ["b" => 2, "a" => 1];
  arsort($array);
  var_dump($array); // ["b" => 2, "a" => 1]
  ```
- **`ksort()`**: Сортирует по ключам.
  ```php
  $array = ["b" => 2, "a" => 1];
  ksort($array);
  var_dump($array); // ["a" => 1, "b" => 2]
  ```
- **`krsort()`**: Сортирует по ключам в обратном порядке.
  ```php
  $array = ["b" => 2, "a" => 1];
  krsort($array);
  var_dump($array); // ["b" => 2, "a" => 1]
  ```
- **`usort()`**: Сортирует с пользовательской функцией сравнения, сбрасывая ключи.
  ```php
  $array = [3, 1, 2];
  usort($array, fn($a, $b) => $a <=> $b);
  var_dump($array); // [0 => 1, 1 => 2, 2 => 3]
  ```
- **`uasort()`**: Сортирует с пользовательской функцией, сохраняя ключи.
  ```php
  $array = ["b" => 2, "a" => 1];
  uasort($array, fn($a, $b) => $a <=> $b);
  var_dump($array); // ["a" => 1, "b" => 2]
  ```
- **`uksort()`**: Сортирует по ключам с пользовательской функцией.
  ```php
  $array = ["b" => 2, "a" => 1];
  uksort($array, fn($a, $b) => $a <=> $b);
  var_dump($array); // ["a" => 1, "b" => 2]
  ```

#### Подводные камни
- **Сброс ключей**: `sort()`, `rsort()`, и `usort()` сбрасывают ключи, что может нарушить ассоциативные массивы.
  ```php
  $array = ["a" => 3, "b" => 1];
  sort($array);
  var_dump($array); // [0 => 1, 1 => 3] — ключи потеряны
  ```
- **Стабильность**: В PHP сортировки нестабильны (одинаковые элементы могут менять порядок). Для стабильной сортировки требуется `usort()` с дополнительной логикой.
  ```php
  $array = [["value" => 1, "id" => 1], ["value" => 1, "id" => 2]];
  usort($array, fn($a, $b) => $a["value"] <=> $b["value"]);
  var_dump($array); // Порядок id может измениться
  ```
- **Производительность `usort()`**: Пользовательская функция сравнения замедляет сортировку из-за накладных расходов на вызовы.
  ```php
  $array = [3, 1, 2];
  usort($array, fn($a, $b) => $a <=> $b); // Медленнее, чем sort()
  ```

> Писать собственную сортировку (например, быструю сортировку) редко оправдано, так как встроенные функции PHP используют оптимизированный алгоритм introsort, реализованный на C.

**Пример пользовательской быстрой сортировки**:
```php
function quickSort(&$array, $left, $right) {
    if ($left < $right) {
        $pivotIndex = partition($array, $left, $right);
        quickSort($array, $left, $pivotIndex - 1);
        quickSort($array, $pivotIndex + 1, $right);
    }
}

function partition(&$array, $left, $right) {
    $pivot = $array[$right];
    $i = $left - 1;
    for ($j = $left; $j < $right; $j++) {
        if ($array[$j] <= $pivot) {
            $i++;
            [$array[$i], $array[$j]] = [$array[$j], $array[$i]];
        }
    }
    [$array[$i + 1], $array[$right]] = [$array[$right], $array[$i + 1]];
    return $i + 1;
}

$array = [3, 1, 2];
quickSort($array, 0, count($array) - 1);
var_dump($array); // [1, 2, 3]
```

### Поиск по массиву

**Бинарный поиск в отсортированном массиве**:
Самый быстрый бинарный поиск применим только после сортировки массива. Стандартные функции (`in_array()`, `array_search()`) не используют бинарный поиск, так как массивы не гарантированно отсортированы => пользовательский бинарный поиск быстрее для больших отсортированных массивов.

```php
function binarySearch($array, $value) {
    $left = 0;
    $right = count($array) - 1;
    while ($left <= $right) {
        $mid = (int)(($left + $right) / 2);
        if ($array[$mid] === $value) {
            return $mid;
        }
        if ($array[$mid] < $value) {
            $left = $mid + 1;
        } else {
            $right = $mid - 1;
        }
    }
    return false;
}

$array = [1, 2, 3, 4, 5];
sort($array); // Необходимо отсортировать
var_dump(binarySearch($array, 3)); // int(2)
```

#### Сравнение производительности
- **Стандартные функции**: Используют introsort (O(n log n) в среднем), оптимизированный на C. Например, `sort()` быстрее пользовательской быстрой сортировки.
- **Пользовательская быстрая сортировка**: O(n log n) в среднем, но медленнее из-за интерпретируемого кода PHP.
- **Бинарный поиск**: O(log n) для поиска в отсортированном массиве, быстрее, чем `array_search()` (O(n)), но требует предварительной сортировки (O(n log n)).

**Тест производительности** (на 10,000 элементов, PHP 8.1):
```php
$array = range(1, 10000);
shuffle($array); // Перемешиваем для реалистичности

$start = microtime(true);
sort($array);
echo "sort: " . (microtime(true) - $start) . " seconds\n";

$array = range(1, 10000);
shuffle($array);
$start = microtime(true);
quickSort($array, 0, count($array) - 1);
echo "quickSort: " . (microtime(true) - $start) . " seconds\n";

$array = range(1, 10000);
sort($array);
$start = microtime(true);
for ($i = 0; $i < 1000; $i++) {
    binarySearch($array, 5000);
}
echo "binarySearch (1000 searches): " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000; $i++) {
    array_search(5000, $array);
}
echo "array_search (1000 searches): " . (microtime(true) - $start) . " seconds\n";
```
**Примерные результаты** (зависят от окружения):
- `sort`: ~0.002 сек
- `quickSort`: ~0.15 сек
- `binarySearch (1000 searches)`: ~0.001 сек
- `array_search (1000 searches)`: ~0.05 сек

**Выводы**:
- Стандартные функции (`sort()`, `asort()`, и т.д.) значительно быстрее пользовательской сортировки благодаря оптимизации на C.
- Пользовательская быстрая сортировка в PHP медленнее (в ~75 раз в тесте) из-за интерпретируемого кода.
- Бинарный поиск быстрее `array_search()` для больших отсортированных массивов, но требует предварительной сортировки.

#### Когда использовать
- **Стандартные функции**: Используйте `sort()`, `asort()`, `ksort()` и их варианты для большинства задач, так как они быстрые, стабильные и простые.
- **Пользовательская сортировка**: Применяйте только в редких случаях, когда требуется специфическая логика, не поддерживаемая `usort()`.
- **Бинарный поиск**: Полезен для частых поисков в больших отсортированных массивах, но требует предварительной сортировки.

#### Советы для собеседований
- На собеседованиях могут спросить:
  - Разницу между `sort()`, `asort()`, и `ksort()`.
  - Почему `usort()` медленнее `sort()`.
  - Когда стоит использовать бинарный поиск вместо `array_search()`.
  - Как реализовать стабильную сортировку в PHP.

---

## Обработка ошибок: от @ к исключениям

Ранние версии PHP использовали оператор `@` для подавления ошибок, но в современном коде предпочтительны исключения.

### Ключевые моменты
- **Оператор `@`**: Подавляет ошибки, но делает код менее прозрачным.
  ```php
  $result = @file_get_contents('nonexistent.txt'); // Ошибка подавлена
  var_dump($result); // bool(false)
  ```
- **Исключения**: Позволяют явно обрабатывать ошибки.
  ```php
  try {
      $content = file_get_contents('nonexistent.txt');
  } catch (Exception $e) {
      echo "Ошибка: " . $e->getMessage();
  }
  ```
- **Throw как выражение** (PHP 8): Позволяет использовать `throw` в тернарных операторах или коротких проверках.
  ```php
  $value = 0;
  $result = $value ?: throw new InvalidArgumentException('Значение не может быть 0');
  var_dump($result); // Вызовет исключение
  ```

### Подводные камни
- Использование `@` может скрыть критические ошибки, усложняя отладку.
- В PHP 8 появились новые типы ошибок, такие как `ValueError`.
  ```php
  // PHP 8
  $number = intdiv(10, 0); // ValueError: Division by zero
  ```

**Совет**: Избегайте `@`, используйте `try-catch` и логирование ошибок (например, с Monolog). На собеседованиях могут спросить, почему `@` считается плохой практикой и как использовать `throw` в PHP 8.

---

## Рекурсия и итерация

Рекурсия — процесс, при котором функция вызывает саму себя для решения задачи, разбивая её на более мелкие подзадачи. Это мощный инструмент, но он может быть ресурсоёмким и сложным для отладки. Итерация, использующая циклы, часто является альтернативой, которая может быть быстрее и потреблять меньше памяти. Этот раздел разбирает рекурсию, способы её замены и сравнение подходов.

### Что такое рекурсия
Рекурсия в PHP работает, когда функция вызывает себя с новыми параметрами, пока не достигнет базового случая, который завершает выполнение. Каждый вызов создаёт новый кадр в стеке вызовов, что увеличивает потребление памяти.

**Пример: Вычисление факториала (рекурсия)**:
```php
function factorial($n) {
    if ($n <= 1) {
        return 1; // Базовый случай
    }
    return $n * factorial($n - 1); // Рекурсивный вызов
}

var_dump(factorial(5)); // int(120) — 5 * 4 * 3 * 2 * 1
```

**Как это работает**:
- `factorial(5)` вызывает `factorial(4)`, затем `factorial(3)`, и так далее, пока не достигается `factorial(1)`.
- Стек вызовов растёт: `[factorial(5), factorial(4), factorial(3), ...]`.
- После достижения базового случая стек разворачивается, вычисляя результат.

**Пример: Обход дерева (рекурсия)**:
```php
function traverseTree($node) {
    if ($node === null) {
        return; // Базовый случай
    }
    echo $node['value'] . "\n";
    traverseTree($node['left']); // Рекурсия для левого поддерева
    traverseTree($node['right']); // Рекурсия для правого поддерева
}

$tree = [
    'value' => 1,
    'left' => ['value' => 2, 'left' => null, 'right' => null],
    'right' => ['value' => 3, 'left' => null, 'right' => null]
];
traverseTree($tree); // Вывод: 1, 2, 3
```

### Переписывание рекурсии в итерацию
Рекурсию можно заменить итерацией, используя циклы (`while`, `for`) и, при необходимости, стек для имитации стека вызовов. Это снижает потребление памяти, так как не создаются новые кадры в стеке.

#### Факториал (итерация)
```php
function factorialIterative($n) {
    $result = 1;
    for ($i = 1; $i <= $n; $i++) {
        $result *= $i;
    }
    return $result;
}

var_dump(factorialIterative(5)); // int(120)
```

**Как это работает**:
- Вместо рекурсивных вызовов используется цикл, накапливающий результат.
- Нет дополнительных кадров в стеке, только одна переменная `$result`.

#### Обход дерева (итерация с использованием стека)
```php
function traverseTreeIterative($root) {
    if ($root === null) {
        return;
    }
    $stack = [$root];
    while (!empty($stack)) {
        $node = array_pop($stack);
        echo $node['value'] . "\n";
        // Добавляем правое поддерево первым, чтобы левое обработалось раньше
        if ($node['right'] !== null) {
            $stack[] = $node['right'];
        }
        if ($node['left'] !== null) {
            $stack[] = $node['left'];
        }
    }
}

traverseTreeIterative($tree); // Вывод: 1, 2, 3
```

**Как это работает**:
- Стек (`$stack`) имитирует стек вызовов, сохраняя узлы для обработки.
- Узлы извлекаются из стека, а их поддеревья добавляются в порядке, обеспечивающем тот же порядок обхода (префиксный).
- Память используется только для стека, а не для кадров вызовов.

### Анализ рекурсии и итерации

#### Производительность
- **Рекурсия**:
  - **Плюсы**: Код часто короче и читаемее, особенно для задач, таких как обход дерева или рекурсивные алгоритмы (например, обход графа).
  - **Минусы**: Каждый вызов создаёт кадр в стеке, увеличивая потребление памяти (O(n) для глубины рекурсии). Глубокая рекурсия может вызвать переполнение стека (`Fatal error: Maximum function nesting level`).
  - Пример: Для `factorial(10000)` рекурсия может исчерпать стек на некоторых системах.
- **Итерация**:
  - **Плюсы**: Не создаёт новых кадров, потребляет меньше памяти (O(1) для простых случаев, O(n) для стека при имитации рекурсии). Обычно быстрее из-за отсутствия накладных расходов на вызовы функций.
  - **Минусы**: Код может быть сложнее и менее интуитивным, особенно для древовидных структур.

**Тест производительности** (на 10,000 итераций, PHP 8.1):
```php
$n = 20;
$iterations = 10000;

// Рекурсивный факториал
$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    factorial($n);
}
echo "factorial (recursive): " . (microtime(true) - $start) . " seconds\n";

// Итеративный факториал
$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    factorialIterative($n);
}
echo "factorial (iterative): " . (microtime(true) - $start) . " seconds\n";

// Рекурсивный обход дерева
$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    traverseTree($tree);
}
echo "traverseTree (recursive): " . (microtime(true) - $start) . " seconds\n";

// Итеративный обход дерева
$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    traverseTreeIterative($tree);
}
echo "traverseTree (iterative): " . (microtime(true) - $start) . " seconds\n";
```
**Примерные результаты** (зависят от окружения):
- `factorial (recursive)`: ~0.08 сек
- `factorial (iterative)`: ~0.03 сек
- `traverseTree (recursive)`: ~0.06 сек
- `traverseTree (iterative)`: ~0.05 сек

**Выводы**:
- Итеративный факториал значительно быстрее (~2.5 раза) из-за отсутствия накладных расходов на вызовы.
- Итеративный обход дерева немного быстрее (~1.2 раза), но разница меньше из-за необходимости управления стеком.
- Для больших входных данных рекурсия может привести к переполнению стека, тогда как итерация более устойчива.

#### Подводные камни
- **Рекурсия**:
  - **Переполнение стека**: Глубокая рекурсия (например, `factorial(100000)`) может вызвать ошибку.
    ```php
    factorial(100000); // Fatal error: Maximum function nesting level
    ```
  - **Хвостовая рекурсия**: PHP не оптимизирует хвостовую рекурсию, в отличие от некоторых языков (например, JavaScript с ES6). Это увеличивает потребление памяти.
    ```php
    function factorialTail($n, $acc = 1) {
        if ($n <= 1) {
            return $acc;
        }
        return factorialTail($n - 1, $n * $acc);
    }
    // Всё равно создаёт стек вызовов
    ```
- **Итерация**:
  - **Сложность кода**: Итеративные решения для сложных задач, таких как обход дерева, могут быть громоздкими.
  - **Ошибки в управлении стеком**: Неправильная работа со стеком (например, неверный порядок добавления узлов) может нарушить логику.
    ```php
    // Ошибка: Неверный порядок добавления в стек
    $stack[] = $node['left'];
    $stack[] = $node['right']; // Поменяет порядок обхода
    ```

#### Когда использовать
- **Рекурсия**:
  - Когда задача естественно рекурсивна (например, обход дерева, графов, рекурсивные алгоритмы, такие как быстрая сортировка).
  - Когда читаемость важнее производительности, а входные данные ограничены.
  - Пример: Обход файловой системы.
    ```php
    function scanDirRecursive($dir) {
        if (!is_dir($dir)) {
            return;
        }
        echo $dir . "\n";
        foreach (scandir($dir) as $file) {
            if ($file !== '.' && $file !== '..') {
                scanDirRecursive($dir . '/' . $file);
            }
        }
    }
    ```
- **Итерация**:
  - Когда важна производительность или входные данные могут быть большими.
  - Когда нужно избежать переполнения стека.
  - Пример: Суммирование элементов массива.
    ```php
    function arraySum($array) {
        $sum = 0;
        foreach ($array as $value) {
            $sum += $value;
        }
        return $sum;
    }
    ```

### Советы для собеседований
- На собеседованиях часто спрашивают:
  - Что такое рекурсия и как она работает в PHP.
  - Как переписать рекурсивный код в итеративный (например, факториал, обход дерева).
  - Почему рекурсия может привести к переполнению стека и как этого избежать.
  - Разницу в производительности между рекурсией и итерацией.
- Подготовьтесь объяснить, как стек вызовов влияет на память и как итерация с использованием стека может заменить рекурсию.
- Практикуйтесь с задачами, такими как вычисление чисел Фибоначчи или обход дерева, в обоих подходах.

**Ресурсы**:
- [Документация PHP: Функции](https://www.php.net/manual/ru/language.functions.php)
- [3v4l.org](https://3v4l.org/) — для тестирования рекурсивного и итеративного кода

---

## Классы и объекты

Объекты в PHP — основа ООП, но их поведение, особенно с магическими методами и сериализацией, полно неочевидных моментов. Этот раздел разбирает создание классов, наследование и типичные ошибки.

### Ключевые моменты
- **Создание классов**: Классы определяют свойства и методы, поддерживают наследование и интерфейсы.
  ```php
  class User {
      public string $name;
      public function __construct(string $name) {
          $this->name = $name;
      }
  }
  $user = new User("Alice");
  var_dump($user->name); // string(5) "Alice"
  ```
- **Магические методы**: Методы вроде `__get`, `__set`, `__toString` перехватывают действия.
  ```php
  class Magic {
      private array $data = [];
      public function __set($name, $value) {
          $this->data[$name] = $value;
      }
      public function __get($name) {
          return $this->data[$name] ?? null;
      }
  }
  $obj = new Magic();
  $obj->key = 42;
  var_dump($obj->key); // int(42)
  ```

### Типичные ошибки
- **Копирование объектов**: Присваивание создаёт ссылку на тот же объект, а не копию.
  ```php
  $user1 = new User("Alice");
  $user2 = $user1;
  $user2->name = "Bob";
  var_dump($user1->name); // string(3) "Bob" — $user1 изменён
  ```
  **Решение**: Используйте `clone` для создания копии.
  ```php
  $user2 = clone $user1;
  $user2->name = "Bob";
  var_dump($user1->name); // string(5) "Alice"
  ```
- **Сериализация**: Метод `__sleep` может ограничить сериализуемые свойства, но ошибки в нём ломают объект.
  ```php
  class Test {
      public $data = 42;
      public function __sleep() {
          return ['wrong']; // Ошибка: свойство не существует
      }
  }
  $obj = new Test();
  serialize($obj); // Warning: serialize(): "wrong" returned as member variable name
  ```
- **Наследование**: Неправильное использование `parent` может вызвать ошибки.
  ```php
  class ParentClass {
      public function test() {
          return "Parent";
      }
  }
  class ChildClass extends ParentClass {
      public function test() {
          return parent::test() . " Child";
      }
  }
  $child = new ChildClass();
  var_dump($child->test()); // string(12) "Parent Child"
  ```

### Производительность
Магические методы (`__get`, `__set`) замедляют доступ к свойствам из-за вызова функций.
```php
class Normal {
    public $value = 42;
}
class Magic {
    private $data = [];
    public function __get($name) {
        return $this->data[$name] ?? 42;
    }
}
$normal = new Normal();
$magic = new Magic();
$iterations = 1000000;

$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    $normal->value;
}
echo "Normal property: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    $magic->value;
}
echo "Magic __get: " . (microtime(true) - $start) . " seconds\n";
```
**Результаты** (PHP 8.1, ориентировочно):
- `Normal property`: ~0.02 сек
- `Magic __get`: ~0.06 сек

### Подводные камни
- **Клонирование**: Глубокое копирование требует реализации `__clone`.
  ```php
  class Deep {
      public $data;
      public function __construct() {
          $this->data = new stdClass();
      }
      public function __clone() {
          $this->data = clone $this->data;
      }
  }
  $obj1 = new Deep();
  $obj2 = clone $obj1;
  $obj2->data->value = 42;
  var_dump($obj1->data->value ?? null); // NULL — копия независима
  ```
- **Сериализация и безопасность**: Сериализованные объекты могут быть уязвимы (например, атака через `__wakeup`).
  ```php
  class Vulnerable {
      public function __wakeup() {
          // Опасный код
      }
  }
  ```
- **Финализация**: Метод `__destruct` не гарантирует немедленный вызов.
  ```php
  class Temp {
      public function __destruct() {
          echo "Destroyed\n";
      }
  }
  $obj = new Temp();
  unset($obj); // Не всегда вызывает "Destroyed" сразу
  ```

### Лайфхаки
- Используйте `clone` для копирования объектов, реализуйте `__clone` для глубокого копирования.
- Избегайте магических методов в высоконагруженных системах из-за накладных расходов.
- Проверяйте сериализуемые данные, чтобы избежать уязвимостей (например, атак через `__wakeup`).
- Для сложных объектов используйте трейты вместо глубокого наследования, чтобы упростить код.
  ```php
  trait Loggable {
      public function log($message) {
          echo "Log: $message\n";
      }
  }
  class User {
      use Loggable;
      public $name;
  }
  $user = new User();
  $user->log("User created"); // Log: User created
  ```

### Советы для собеседований
- Часто спрашивают:
  - Разницу между присваиванием объекта и `clone`.
  - Как работают магические методы (`__get`, `__set`, `__toString`).
  - Как избежать уязвимостей при сериализации.
  - Почему `__destruct` не всегда вызывается сразу.
- Подготовьтесь объяснить, как `__clone` влияет на глубокое копирование и как трейты упрощают ООП.
- Практикуйтесь с задачами, например, реализация `__toString` для вывода объекта или обработка `__wakeup` для безопасной десериализации.

**Ресурсы**:
- [Документация PHP: Классы и объекты](https://www.php.net/manual/ru/language.oop5.php)
- [Документация PHP: Трейты](https://www.php.net/manual/ru/language.oop5.traits.php)
- [3v4l.org](https://3v4l.org/) — для тестирования ООП-кода

---

## Управление памятью

PHP имеет автоматическое управление памятью через сборщик мусора, но неправильное использование ресурсов может привести к утечкам или снижению производительности. Этот раздел разбирает, как работает память в PHP, и как избежать типичных проблем.

### Ключевые моменты
- **Сборка мусора**: PHP использует подсчёт ссылок и периодическую очистку циклических ссылок.
  ```php
  class Node {
      public $next;
  }
  $a = new Node();
  $b = new Node();
  $a->next = $b;
  $b->next = $a; // Циклическая ссылка
  unset($a, $b); // Объекты не удаляются сразу
  gc_collect_cycles(); // Принудительная очистка
  ```
- **Освобождение памяти**: `unset()` удаляет ссылку, но не всегда освобождает память немедленно.
  ```php
  $array = range(1, 1000000);
  unset($array); // Память освобождается сборщиком мусора
  ```

### Типичные ошибки
- **Утечки памяти**: Циклические ссылки или большие массивы в долгоживущих скриптах могут накапливать память.
  ```php
  $data = [];
  while (true) {
      $data[] = range(1, 1000); // Утечка памяти
  }
  ```
  **Решение**: Очищайте массивы с `unset()` или используйте `null`.
  ```php
  $data = null; // Быстрее освобождает память
  ```
- **Неэффективное использование памяти**: Хранение больших данных в переменных без необходимости.
  ```php
  $data = file_get_contents('large.txt'); // Может исчерпать память
  ```
  **Решение**: Используйте потоки или генераторы.
  ```php
  $handle = fopen('large.txt', 'r');
  while ($line = fgets($handle)) {
      // Обработка строки
  }
  fclose($handle);
  ```

### Производительность
`unset()` быстрее, чем присваивание `null`, но оба метода зависят от сборщика мусора.
```php
$iterations = 1000;
$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    $array = range(1, 100000);
    unset($array);
}
echo "unset: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    $array = range(1, 100000);
    $array = null;
}
echo "null: " . (microtime(true) - $start) . " seconds\n";
```
**Результаты** (PHP 8.1, ориентировочно):
- `unset`: ~0.5 сек
- `null`: ~0.6 сек

### Подводные камни
- **Сборщик мусора**: Циклические ссылки очищаются только при вызове сборщика, что может задерживать освобождение памяти.
- **Ограничения памяти**: Настройка `memory_limit` может быть превышена при работе с большими данными.
  ```php
  ini_set('memory_limit', '128M');
  $array = range(1, 10000000); // Fatal error: Allowed memory size exhausted
  ```
- **WeakReference**: Не всегда предотвращает утечки, если объект удерживается другими ссылками.

### Лайфхаки
- Используйте `unset()` или `null` для больших массивов в циклах.
- Применяйте `gc_collect_cycles()` в долгоживущих скриптах для принудительной очистки.
- Работайте с потоками (`fopen`, `fgets`) для больших файлов вместо `file_get_contents()`.
- Используйте генераторы для обработки больших данных:
  ```php
  function readLines($file) {
      $handle = fopen($file, 'r');
      while ($line = fgets($handle)) {
          yield $line;
      }
      fclose($handle);
  }
  foreach (readLines('large.txt') as $line) {
      // Обработка строки
  }
  ```

### Советы для собеседований
- Часто спрашивают:
  - Как работает сборщик мусора в PHP.
  - Как избежать утечек памяти в долгоживущих скриптах.
  - Разницу между `unset()` и присваиванием `null`.
- Подготовьтесь объяснить, как циклические ссылки влияют на память и как их очищать.
- Практикуйтесь с задачами, например, оптимизация обработки больших файлов.

**Ресурсы**:
- [Документация PHP: Сборщик мусора](https://www.php.net/manual/ru/features.gc.php)
- [Документация PHP: Генераторы](https://www.php.net/manual/ru/language.generators.php)

---

## Типичные вопросы на собеседованиях

Собеседования по PHP часто включают вопросы, проверяющие понимание основ языка, типичных ошибок и подводных камней. Ниже — подборка задач с кодом, ответами и пояснениями, охватывающая ключевые темы: типы данных, ссылки, строки, области видимости, массивы, рекурсию, ошибки, объекты и управление памятью. Эти вопросы помогут подготовиться к интервью и избежать ловушек.

1. **Что выведет этот код?**
   ```php
   $a = 5;
   $b = "5";
   var_dump($a == $b, $a === $b);
   ```
   **Ответ**: `bool(true), bool(false)`  
   **Пояснение**: Оператор `==` приводит типы, сравнивая значения (`5` равно `"5"`), а `===` проверяет значение и тип (`int` ≠ `string`).  
   **Связь с разделом**: «Типы данных и сравнения».

2. **Почему этот код вызовет ошибку?**
   ```php
   function test($a, $b = 10) {
       echo $a + $b;
   }
   test();
   ```
   **Ответ**: `Fatal error: Uncaught ArgumentCountError`  
   **Пояснение**: Параметр `$a` обязателен, так как не имеет значения по умолчанию, а `$b` — необязательный. Вызов `test()` без аргументов вызывает ошибку.  
   **Связь с разделом**: «Области видимости и замыкания».

3. **Что выведет этот код?**
   ```php
   $array = [1, 2, 3];
   unset($array[1]);
   var_dump(array_values($array));
   ```
   **Ответ**: `array(2) { [0]=> int(1) [1]=> int(3) }`  
   **Пояснение**: `unset($array[1])` удаляет элемент с индексом `1`, оставляя `[0 => 1, 2 => 3]`. Функция `array_values()` переиндексирует массив, создавая `[0 => 1, 1 => 3]`.  
   **Связь с разделом**: «Массивы и их особенности».

4. **Как работает замыкание в этом коде?**
   ```php
   $x = 10;
   $closure = function() use ($x) {
       return $x;
   };
   $x = 20;
   echo $closure();
   ```
   **Ответ**: `10`  
   **Пояснение**: Замыкание захватывает значение `$x` на момент создания через `use` (по значению, не по ссылке). Изменение `$x` после создания замыкания не влияет на результат.  
   **Связь с разделом**: «Области видимости и замыкания».

5. **Что выведет этот код и как исправить ошибку?**
   ```php
   $array = [1, 2, 3];
   foreach ($array as &$item) {
       $item *= 2;
   }
   $item = 10;
   var_dump($array);
   ```
   **Ответ**: `array(3) { [0]=> int(2) [1]=> int(4) [2]=> int(10) }`  
   **Пояснение**: В цикле `foreach` с `&` переменная `$item` остаётся ссылкой на последний элемент массива. Присваивание `$item = 10` изменяет `$array[2]`.  
   **Исправление**: Используйте `unset($item)` после цикла.
   ```php
   foreach ($array as &$item) {
       $item *= 2;
   }
   unset($item);
   ```
   **Связь с разделом**: «Ссылки и переменные переменных».

6. **Что выведет этот код?**
   ```php
   $name = "price";
   $$name = 100;
   var_dump($price);
   ```
   **Ответ**: `int(100)`  
   **Пояснение**: Переменная переменных `$$name` создаёт переменную `$price`, так как `$name` содержит строку `"price"`. Это эквивалентно `$price = 100`.  
   **Подводный камень**: Использование `$$var` с пользовательским вводом опасно, лучше применять массивы.  
   **Связь с разделом**: «Ссылки и переменные переменных».

7. **Что выведет этот код и почему?**
   ```php
   function factorial($n) {
       if ($n <= 1) {
           return 1;
       }
       return $n * factorial($n - 1);
   }
   echo factorial(5);
   ```
   **Ответ**: `120`  
   **Пояснение**: Функция рекурсивно вычисляет факториал: `5 * factorial(4) * factorial(3) * ... * 1 = 5 * 4 * 3 * 2 * 1 = 120`. Каждый вызов создаёт кадр в стеке.  
   **Подводный камень**: Глубокая рекурсия (например, `factorial(100000)`) может вызвать переполнение стека.  
   **Связь с разделом**: «Рекурсия и итерация».

8. **Что выведет этот код?**
   ```php
   $array = [3, 1, 2];
   sort($array);
   var_dump($array);
   ```
   **Ответ**: `array(3) { [0]=> int(1) [1]=> int(2) [2]=> int(3) }`  
   **Пояснение**: Функция `sort()` сортирует массив по значениям в порядке возрастания, сбрасывая ключи. Исходный массив `[3, 1, 2]` становится `[1, 2, 3]` с новыми индексами.  
   **Подводный камень**: Для сохранения ключей используйте `asort()`.  
   **Связь с разделом**: «Массивы и их особенности».

9. **Что выведет этот код и как его улучшить?**
   ```php
   $result = @file_get_contents('nonexistent.txt');
   var_dump($result);
   ```
   **Ответ**: `bool(false)`  
   **Пояснение**: Оператор `@` подавляет ошибку, возвращая `false` при неудаче. Это устаревший подход, затрудняющий отладку.  
   **Улучшение**: Используйте `try-catch` для явной обработки ошибок.
   ```php
   try {
       $content = file_get_contents('nonexistent.txt');
   } catch (Exception $e) {
       $content = false;
       echo "Ошибка: " . $e->getMessage();
   }
   var_dump($content);
   ```
   **Связь с разделом**: «Обработка ошибок: от @ к исключениям».

10. **Что выведет этот код?**
    ```php
    $object = new stdClass();
    $weakRef = WeakReference::create($object);
    unset($object);
    var_dump($weakRef->get());
    ```
    **Ответ**: `NULL`  
    **Пояснение**: `WeakReference` создаёт слабую ссылку на объект, которая не предотвращает его удаление сборщиком мусора. После `unset($object)` объект удаляется, и `$weakRef->get()` возвращает `NULL`.  
    **Подводный камень**: `WeakReference` поддерживается только в PHP 7.4+ и работает только с объектами.  
    **Связь с разделом**: «Ссылки и переменные переменных».

11. **Что выведет этот код и как его исправить?**
    ```php
    $str = "Привет, мир!";
    var_dump(substr($str, 0, 6));
    ```
    **Ответ**: `string(6) "Приве"` (некорректно обрезает UTF-8 символ)  
    **Пояснение**: `substr()` считает байты, а не символы, что ломает многобайтные строки.  
    **Исправление**: Используйте `mb_substr()`.
    ```php
    var_dump(mb_substr($str, 0, 6)); // string(12) "Привет"
    ```
    **Связь с разделом**: «Строки и кодировки».

12. **Что выведет этот код?**
    ```php
    class User {
        public $name = "Alice";
    }
    $user1 = new User();
    $user2 = $user1;
    $user2->name = "Bob";
    var_dump($user1->name);
    ```
    **Ответ**: `string(3) "Bob"`  
    **Пояснение**: Присваивание объекта создаёт ссылку на тот же объект. Изменение `$user2->name` меняет `$user1->name`.  
    **Решение**: Используйте `clone` для копии.  
    **Связь с разделом**: «Классы и объекты».

13. **Почему этот код может вызвать проблемы и как его оптимизировать?**
    ```php
    $data = [];
    for ($i = 0; $i < 1000; $i++) {
        $data[] = range(1, 10000);
    }
    ```
    **Ответ**: Код накапливает память, что может привести к `Fatal error: Allowed memory size exhausted`.  
    **Пояснение**: Большие массивы в цикле не очищаются, пока не сработает сборщик мусора.  
    **Оптимизация**: Очищайте массив с `unset()` или используйте `null`.
    ```php
    $data = [];
    for ($i = 0; $i < 1000; $i++) {
        $data[] = range(1, 10000);
        $data = []; // Очистка
    }
    ```
    **Связь с разделом**: «Управление памятью».

**Совет**: Практикуйтесь с этими вопросами, чтобы уверенно разбирать код на собеседованиях. Используйте [3v4l.org](https://3v4l.org/) для проверки поведения кода на разных версиях PHP. Обратите внимание на подводные камни, такие как ошибки с `foreach` и `&`, переполнение стека в рекурсии, устаревшие практики вроде `@`, и неправильная работа с UTF-8 строками. Для углублённой подготовки попробуйте переписать рекурсивные функции итеративно, оптимизировать код с учётом производительности или обработать большие данные с минимальным потреблением памяти.

**Ресурсы**:
- [Документация PHP](https://www.php.net/manual/ru/)
- [PHP The Right Way](https://phptherightway.com/) — лучшие практики
- [3v4l.org](https://3v4l.org/) — онлайн-песочница для тестирования кода