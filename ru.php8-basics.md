# 🐘 Основы PHP: ключевые концепции и подводные камни

Эта глава — компактный обзор основ PHP, ориентированный на джуниоров, которые формируют базу знаний, и опытных разработчиков, готовящихся к собеседованиям или желающих освежить знания. Здесь мы разберем типичные ошибки, нюансы языка и вопросы, которые часто встречаются на технических интервью. Без лишней «воды», только практичные примеры и подводные камни.

## 📚 Содержание

- [Типы данных и сравнения](#типы-данных-и-сравнения)
- [Области видимости и замыкания](#области-видимости-и-замыкания)
- [Массивы и их особенности](#массивы-и-их-особенности)
- [Обработка ошибок: от @ к исключениям](#обработка-ошибок)
- [Типичные вопросы на собеседованиях](#типичные-вопросы-на-собеседованиях)

## Типы данных и сравнения

PHP — динамически типизированный язык, но его поведение с типами данных часто вызывает путаницу. Основные типы: `int`, `float`, `string`, `bool`, `array`, `object`, `null`.

### Подводные камни
- **Сравнение с `==` и `===`**: Оператор `==` приводит типы перед сравнением, что может привести к неожиданным результатам. Используйте `===` для строгого сравнения (значение и тип).
  ```php
  $a = "10";
  $b = 10;
  var_dump($a == $b);  // bool(true) — приводит строку к числу
  var_dump($a === $b); // bool(false) — разные типы
  ```
- **Числа и строки**: Приведение строк к числам может быть неочевидным.
  ```php
  $str = "123abc";
  var_dump((int)$str); // int(123) — PHP игнорирует нечисловые символы
  ```

### Логические значения

Функции `empty()`, `isset()`, `is_null()`, оператор `=== null`, и `key_exists()` используются для проверки переменных и элементов массивов, но их поведение имеет важные различия, которые часто приводят к ошибкам.

- **`empty($var)`**: Проверяет, является ли переменная «пустой». Считает «пустыми» значения: `false`, `0`, `0.0`, `""`, `"0"`, `null`, `[]`, и неинициализированные переменные.
- **`isset($var)`**: Проверяет, существует ли переменная и не равна ли она `null`.
- **`is_null($var)`**: Проверяет, равна ли переменная строго `null`. Выбрасывает `E_WARNING`, если переменная не определена.
- **`=== null`**: Строгое сравнение с `null`, проверяет, является ли значение переменной `null`. Также выбрасывает `E_WARNING` для неопределенной переменной.
- **`key_exists($key, $array)`**: Проверяет, существует ли указанный ключ в массиве (синоним `array_key_exists`).

#### Пример с переменной
```php
$var = "0";
$nullVar = null;
$unsetVar;

var_dump(empty($var));        // bool(true) — строка "0" считается пустой
var_dump(isset($var));        // bool(true) — переменная существует
var_dump(is_null($var));      // bool(false) — переменная не null
var_dump($var === null);      // bool(false) — переменная не null
var_dump(empty($nullVar));    // bool(true) — null считается пустым
var_dump(isset($nullVar));    // bool(false) — null не проходит проверку isset
var_dump(is_null($nullVar));  // bool(true) — явно null
var_dump($nullVar === null);  // bool(true) — явно null
var_dump(empty($unsetVar));   // bool(true) — неинициализированная переменная пуста
var_dump(isset($unsetVar));   // bool(false) — неинициализированная переменная не существует
var_dump(is_null($unsetVar)); // bool(true) — неинициализированная переменная считается null
var_dump($unsetVar === null); // bool(true) — неинициализированная переменная равна null
```

#### Пример с массивом
```php
$array = ["key" => "value", "empty" => "", "zero" => 0, "null" => null];

var_dump(key_exists("key", $array));   // bool(true) — ключ существует
var_dump(key_exists("missing", $array)); // bool(false) — ключ отсутствует
var_dump(isset($array["null"]));       // bool(false) — значение null не проходит isset
var_dump(empty($array["zero"]));       // bool(true) — значение 0 считается пустым
var_dump(is_null($array["null"]));     // bool(true) — значение явно null
var_dump($array["null"] === null);     // bool(true) — значение равно null
```

#### Подводные камни
- `empty()` возвращает `true` для строки `"0"`, что может быть неожиданным, если `"0"` — валидное значение.
- `isset()` возвращает `false` для `null`, даже если ключ существует в массиве.
- `is_null()` и `=== null` ведут себя одинаково для существующих переменных, но оба вызывают `E_WARNING` для неопределенных переменных, в отличие от `isset()`.
  ```php
  var_dump(is_null($undefined)); // bool(true) + E_WARNING
  var_dump($undefined === null); // bool(true) + E_WARNING
  var_dump(isset($undefined));   // bool(false) — без предупреждения
  ```
- `key_exists()` проверяет только наличие ключа, игнорируя значение, в отличие от `isset()`.

#### Сравнение `is_null()` и `=== null`
- **Поведение**: Оба проверяют, является ли значение строго `null`. Для определенных переменных они идентичны по результату.
  ```php
  $var = null;
  var_dump(is_null($var));  // bool(true)
  var_dump($var === null);  // bool(true)
  ```
- **Различия**:
    - `is_null()` — это функция, которая явно предназначена для проверки `null`. Она более читаема в сложных условиях.
    - `=== null` — это оператор сравнения, который может быть менее очевидным в коде, особенно если переменная сравнивается с другими значениями.
    - Для неопределенных переменных оба вызывают `E_WARNING`, но `isset()` позволяет избежать предупреждения.
- **Когда использовать**:
    - Используйте `is_null()`, если хотите явно подчеркнуть проверку на `null` (например, в документации или для читаемости).
    - Используйте `=== null`, если проверка встроена в более сложное условие, например:
      ```php
      if ($var === null || $var === 0) {
          echo "Переменная либо null, либо 0";
      }
      ```
    - Для проверки существования переменной перед проверкой на `null` используйте `isset()`:
      ```php
      if (isset($var) && $var === null) {
          echo "Переменная существует и равна null";
      }
      ```

#### Производительность
Тестирование показывает, что `isset()` — самая быстрая функция для проверки существования переменной или ключа, так как она выполняется на уровне движка PHP. `=== null` быстрее, чем `is_null()`, так как это оператор, а не вызов функции. `is_null()` медленнее из-за накладных расходов на вызов функции. `empty()` медленнее всех, так как проверяет существование и «пустоту». `key_exists()` — самый медленный, так как работает с хэш-таблицей массива.

**Пример теста производительности** (на 1 млн итераций, PHP 8.1):
```php
$var = null;
$array = ["key" => "value"];
$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    isset($var);
}
echo "isset: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    $var === null;
}
echo "=== null: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    is_null($var);
}
echo "is_null: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    empty($var);
}
echo "empty: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    key_exists("key", $array);
}
echo "key_exists: " . (microtime(true) - $start) . " seconds\n";
```
**Примерные результаты** (зависят от окружения):
- `isset`: ~0.03 сек
- `=== null`: ~0.04 сек
- `is_null`: ~0.05 сек
- `empty`: ~0.07 сек
- `key_exists`: ~0.09 сек

**Совет**: Используйте `isset()` для проверки существования переменных или ключей, чтобы избежать предупреждений. Для проверки на `null` предпочтите `=== null` в простых случаях из-за большей скорости, а `is_null()` — для читаемости. Избегайте `empty()`, если строка `"0"` — валидное значение. На собеседованиях часто спрашивают разницу между `is_null()`, `=== null`, и `isset()`, а также их влияние на производительность.

## Области видимости и замыкания

PHP имеет три основные области видимости: глобальная, локальная и статическая. Неправильное понимание областей приводит к ошибкам, особенно в замыканиях.

### Ключевые моменты
- **Глобальная область**: Переменные, объявленные вне функций, не доступны внутри без `global` или `$GLOBALS`.
  ```php
  $x = 10;
  function test() {
      global $x;
      echo $x; // 10
  }
  test();
  ```
- **Статические переменные**: Сохраняют значение между вызовами функции.
  ```php
  function counter() {
      static $count = 0;
      return ++$count;
  }
  echo counter(); // 1
  echo counter(); // 2
  ```
- **Замыкания**: Анонимные функции могут захватывать переменные с помощью `use`, но по умолчанию они передаются по значению.
  ```php
  $x = 10;
  $closure = function() use ($x) {
      return $x;
  };
  $x = 20;
  echo $closure(); // 10 — захвачено исходное значение
  ```

### Подводные камни
- Изменение захваченной переменной в замыкании требует передачи по ссылке (`use (&$x)`).
  ```php
  $x = 10;
  $closure = function() use (&$x) {
      $x++;
  };
  $closure();
  echo $x; // 11
  ```

**Совет**: Избегайте `global`, используйте параметры функций или замыкания для передачи данных. На собеседованиях часто спрашивают, как работает `use` в замыканиях.

## Массивы и их особенности

Массивы в PHP — мощный инструмент, поддерживающий числовые и ассоциативные ключи, но их поведение может быть неочевидным. Неправильное использование массивов или функций для работы с ними часто приводит к ошибкам, особенно у начинающих разработчиков. Этот раздел разбирает типичные ошибки и функции, в которых путаются, а также дает советы для собеседований.

### Ключевые моменты
- **Числовые и ассоциативные массивы**: PHP автоматически присваивает числовые ключи, но их можно смешивать со строковыми, что иногда вызывает путаницу.
  ```php
  $array = [1, 2, "key" => "value"];
  var_dump($array); // [0 => 1, 1 => 2, "key" => "value"]
  ```
- **Операторы объединения**: Оператор `+` и функция `array_merge()` ведут себя по-разному.
  ```php
  $a = ["a" => 1, "b" => 2];
  $b = ["b" => 3, "c" => 4];
  $result = $a + $b; // ["a" => 1, "b" => 2, "c" => 4] — сохраняет первые значения ключей
  $merged = array_merge($a, $b); // ["a" => 1, "b" => 3, "c" => 4] — перезаписывает ключи
  ```
- **Удаление элементов**: `unset()` не переиндексирует числовые ключи, что может нарушить логику.
  ```php
  $array = [0, 1, 2];
  unset($array[1]);
  var_dump($array); // [0 => 0, 2 => 2]
  var_dump(array_values($array)); // [0 => 0, 1 => 2] — переиндексация
  ```

### Типичные ошибки
- **Смешивание ключей**: Числовые и строковые ключи могут конфликтовать, особенно если строка интерпретируется как число.
  ```php
  $array = [10, "1" => 20];
  var_dump($array); // [0 => 10, 1 => 20] — ключ "1" интерпретируется как числовой
  ```
- **Неверное использование `unset` в циклах**: Удаление элементов в цикле `foreach` может привести к пропуску элементов.
  ```php
  $array = [1, 2, 3];
  foreach ($array as $key => $value) {
      unset($array[$key]);
  }
  var_dump($array); // [] — массив очищен
  ```
  **Ошибка**: Если использовать `foreach` с изменением массива, итератор может пропустить элементы. Используйте `array_filter` или цикл `for` для безопасного удаления.
  ```php
  $array = [1, 2, 3];
  $array = array_filter($array, fn($value) => $value != 2);
  var_dump($array); // [0 => 1, 2 => 3]
  ```
- **Неправильная проверка существования**: Использование `isset()` вместо `array_key_exists()` для проверки ключей с `null` значением.
  ```php
  $array = ["key" => null];
  var_dump(isset($array["key"])); // bool(false) — не проходит для null
  var_dump(array_key_exists("key", $array)); // bool(true) — ключ существует
  ```

### Функции, в которых путаются
- **`array_merge()`**: Объединяет массивы, перезаписывая значения одинаковых ключей. Для числовых ключей создает новые индексы.
  ```php
  $a = [1, 2];
  $b = [3, 4];
  var_dump(array_merge($a, $b)); // [0 => 1, 1 => 2, 2 => 3, 3 => 4]
  ```

- **`array_column()`**: Извлекает значения определенного ключа из массива записей. Полезно для обработки данных из БД.
  ```php
  $users = [
      ["id" => 1, "name" => "Alice"],
      ["id" => 2, "name" => "Bob"]
  ];
  $names = array_column($users, "name");
  var_dump($names); // ["Alice", "Bob"]
  ```
  
  **Подводный камень**: Если ключ отсутствует в записи, `array_column()` пропустит эту запись.
  ```php
  $users = [
      ["id" => 1],
      ["name" => "Bob"]
  ];
  var_dump(array_column($users, "id")); // [1] — запись без ключа "id" игнорируется
  ```

- **`array_combine()`**: Создает массив, используя один массив как ключи, а другой как значения.
  ```php
  $keys = ["id1", "id2"];
  $values = ["Alice", "Bob"];
  var_dump(array_combine($keys, $values)); // ["id1" => "Alice", "id2" => "Bob"]
  ```
  **Пример с БД**: Создание словаря ID → имя из результата запроса.
  ```php
  $users = [
      ["id" => 1, "name" => "Alice"],
      ["id" => 2, "name" => "Bob"]
  ];
  $idToName = array_combine(
      array_column($users, "id"),
      array_column($users, "name")
  );
  var_dump($idToName); // [1 => "Alice", 2 => "Bob"]
  ```
  **Подводный камень**: Оба массива должны иметь одинаковую длину, иначе ошибка.
  ```php
  $keys = ["a", "b"];
  $values = [1];
  var_dump(array_combine($keys, $values)); // ValueError (PHP 8+)
  ```
- **`array_key_exists()` (или `key_exists`)**: Проверяет наличие ключа в массиве, даже если значение `null`.
  ```php
  $array = ["key" => null];
  var_dump(array_key_exists("key", $array)); // bool(true)
  ```
  **Подводный камень**: Медленнее, чем `isset()`, но необходим для проверки ключей с `null`.


- **`in_array()`**: Проверяет наличие значения в массиве.
  ```php
  $array = [1, "2", 3];
  var_dump(in_array("2", $array)); // bool(true) — приводит типы
  var_dump(in_array("2", $array, true)); // bool(true) — строгое сравнение
  ```
  **Подводный камень**: Без третьего параметра (`strict = true`) выполняется приведение типов, что может дать ложный результат.
  ```php
  var_dump(in_array("2", [2])); // bool(true) — приводит строку к числу
  ```
- **`array_search()`**: Возвращает ключ первого найденного значения или `false`, если значение не найдено.
  ```php
  $array = ["a" => 1, "b" => 2, "c" => 1];
  var_dump(array_search(1, $array)); // string(1) "a" — первый ключ
  ```
  **Подводный камень**: Без строгого сравнения (`strict = true`) может вернуть неверный ключ из-за приведения типов.
  ```php
  var_dump(array_search("2", [2])); // int(0) — приводит типы
  var_dump(array_search("2", [2], true)); // bool(false) — строгое сравнение
  ```
- **`array_map()`**: Применяет функцию к каждому элементу массива, возвращая новый массив.
  ```php
  $array = [1, 2, 3];
  $result = array_map(fn($value) => $value * 2, $array);
  var_dump($result); // [2, 4, 6]
  ```
  **Сравнение с `foreach`**:
    - `array_map()`: Функциональный стиль, возвращает новый массив, не изменяет исходный.
      ```php
      $array = [1, 2, 3];
      $result = array_map(fn($value) => $value + 1, $array);
      var_dump($result); // [2, 3, 4]
      var_dump($array); // [1, 2, 3] — исходный массив неизменен
      ```
    - `foreach`: Императивный стиль, может изменять исходный массив.
      ```php
      $array = [1, 2, 3];
      foreach ($array as &$value) {
          $value += 1;
      }
      var_dump($array); // [2, 3, 4] — исходный массив изменен
      ```
  **Подводный камень**: `array_map()` не может изменять исходный массив напрямую и требует возврата нового массива. `foreach` удобнее для модификации массива, но менее читаем в функциональном стиле.
  **Производительность**: `array_map()` обычно медленнее `foreach` из-за вызова функции для каждого элементада
> Кроме того, `foreach` - проще для чтения. Так что лично я не люблю `array_map`, хотя встречал отдельных деятелей, которые на код-ревью просили переписать foreach на array_map. Осуждаю, не будьте такими!


### Подводные камни
- **Пустота массива**: `empty($array)` возвращает `true` только для пустого массива, но `[0]` или `[""]` не считаются пустыми.
  ```php
  $array = [0];
  var_dump(empty($array)); // bool(false)
  ```
- **Передача по ссылке**: Изменение массива в функции требует явной передачи по ссылке.
  ```php
  function modifyArray($array) {
      $array[] = 4; // Не изменяет исходный массив
  }
  $array = [1, 2, 3];
  modifyArray($array);
  var_dump($array); // [1, 2, 3]
  ```
  **Решение**: Используйте `&` для передачи по ссылке.
  ```php
  function modifyArray(&$array) {
      $array[] = 4;
  }
  modifyArray($array);
  var_dump($array); // [1, 2, 3, 4]
  ```
- **Автоинкремент ключей**: PHP автоматически увеличивает числовые ключи, что может нарушить логику.
  ```php
  $array = [0 => "a", 2 => "b"];
  $array[] = "c";
  var_dump($array); // [0 => "a", 2 => "b", 3 => "c"] — следующий числовой ключ
  ```

### Производительность
Функции работы с массивами, такие как `array_key_exists()`, `in_array()`, `array_search()`, и `array_map()`, медленнее, чем `isset()`, из-за работы с хэш-таблицами. `array_merge()` быстрее, чем `+`, для больших массивов. `array_map()` медленнее `foreach` из-за накладных расходов на вызов функции.

**Пример теста производительности** (на 1 млн итераций, PHP 8.1):
```php
$array = ["key" => "value"];
$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    isset($array["key"]);
}
echo "isset: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    array_key_exists("key", $array);
}
echo "array_key_exists: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    in_array("value", $array);
}
echo "in_array: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    array_search("value", $array);
}
echo "array_search: " . (microtime(true) - $start) . " seconds\n";

$array = [1, 2, 3];
$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    array_map(fn($value) => $value * 2, $array);
}
echo "array_map: " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000000; $i++) {
    $result = [];
    foreach ($array as $value) {
        $result[] = $value * 2;
    }
}
echo "foreach: " . (microtime(true) - $start) . " seconds\n";
```
**Примерные результаты** (зависят от окружения):
- `isset`: ~0.03 сек
- `array_key_exists`: ~0.09 сек
- `in_array`: ~0.11 сек
- `array_search`: ~0.12 сек
- `array_map`: ~0.15 сек
- `foreach`: ~0.10 сек

### Советы
- Используйте `array_merge()` вместо `+` для объединения массивов, чтобы избежать потери данных.
- Проверяйте ключи с `array_key_exists()`, если значение может быть `null`; для скорости используйте `isset()`.
- Для поиска значений указывайте `strict = true` в `in_array()` и `array_search()`, чтобы избежать приведения типов.
- Используйте `array_map()` для функционального стиля, а `foreach` — для изменения массива или большей скорости.
- На собеседованиях часто спрашивают:
    - Разницу между `array_merge()` и `+`.
    - Почему `unset` в `foreach` опасен.
    - Разницу между `isset()` и `array_key_exists()`.
    - Как работают `array_map()` и `array_column()`, либо любой из десятков других методов работы с массивами.

### Сортировка массивов и поиск

PHP предоставляет набор встроенных функций для сортировки массивов, которые оптимизированы на уровне движка и используют алгоритм introsort (гибрид быстрой сортировки, пирамидальной сортировки и сортировки вставками). Писать собственную сортировку редко оправдано, но полезно понимать, как работают стандартные функции и их производительность.

#### Стандартные функции сортировки
- **`sort()`**: Сортирует массив по значениям, сбрасывая ключи (числовая индексация с 0).
  ```php
  $array = [3, 1, 2];
  sort($array);
  var_dump($array); // [0 => 1, 1 => 2, 2 => 3]
  ```
- **`rsort()`**: Сортирует по значениям в обратном порядке, сбрасывая ключи.
  ```php
  $array = [3, 1, 2];
  rsort($array);
  var_dump($array); // [0 => 3, 1 => 2, 2 => 1]
  ```
- **`asort()`**: Сортирует по значениям, сохраняя ключи.
  ```php
  $array = ["b" => 2, "a" => 1];
  asort($array);
  var_dump($array); // ["a" => 1, "b" => 2]
  ```
- **`arsort()`**: Сортирует по значениям в обратном порядке, сохраняя ключи.
  ```php
  $array = ["b" => 2, "a" => 1];
  arsort($array);
  var_dump($array); // ["b" => 2, "a" => 1]
  ```
- **`ksort()`**: Сортирует по ключам.
  ```php
  $array = ["b" => 2, "a" => 1];
  ksort($array);
  var_dump($array); // ["a" => 1, "b" => 2]
  ```
- **`krsort()`**: Сортирует по ключам в обратном порядке.
  ```php
  $array = ["b" => 2, "a" => 1];
  krsort($array);
  var_dump($array); // ["b" => 2, "a" => 1]
  ```
- **`usort()`**: Сортирует с пользовательской функцией сравнения, сбрасывая ключи.
  ```php
  $array = [3, 1, 2];
  usort($array, fn($a, $b) => $a <=> $b);
  var_dump($array); // [0 => 1, 1 => 2, 2 => 3]
  ```
- **`uasort()`**: Сортирует с пользовательской функцией, сохраняя ключи.
  ```php
  $array = ["b" => 2, "a" => 1];
  uasort($array, fn($a, $b) => $a <=> $b);
  var_dump($array); // ["a" => 1, "b" => 2]
  ```
- **`uksort()`**: Сортирует по ключам с пользовательской функцией.
  ```php
  $array = ["b" => 2, "a" => 1];
  uksort($array, fn($a, $b) => $a <=> $b);
  var_dump($array); // ["a" => 1, "b" => 2]
  ```

#### Подводные камни
- **Сброс ключей**: `sort()`, `rsort()`, и `usort()` сбрасывают ключи, что может нарушить ассоциативные массивы.
  ```php
  $array = ["a" => 3, "b" => 1];
  sort($array);
  var_dump($array); // [0 => 1, 1 => 3] — ключи потеряны
  ```
- **Стабильность**: В PHP сортировки нестабильны (одинаковые элементы могут менять порядок). Для стабильной сортировки требуется `usort()` с дополнительной логикой.
  ```php
  $array = [["value" => 1, "id" => 1], ["value" => 1, "id" => 2]];
  usort($array, fn($a, $b) => $a["value"] <=> $b["value"]);
  var_dump($array); // Порядок id может измениться
  ```
- **Производительность `usort()`**: Пользовательская функция сравнения замедляет сортировку из-за накладных расходов на вызовы.
  ```php
  $array = [3, 1, 2];
  usort($array, fn($a, $b) => $a <=> $b); // Медленнее, чем sort()
  ```

>Писать собственную сортировку (например, быструю сортировку) редко оправдано, так как встроенные функции PHP используют оптимизированный алгоритм introsort, реализованный на C.

**Пример пользовательской быстрой сортировки**:
```php
function quickSort(&$array, $left, $right) {
    if ($left < $right) {
        $pivotIndex = partition($array, $left, $right);
        quickSort($array, $left, $pivotIndex - 1);
        quickSort($array, $pivotIndex + 1, $right);
    }
}

function partition(&$array, $left, $right) {
    $pivot = $array[$right];
    $i = $left - 1;
    for ($j = $left; $j < $right; $j++) {
        if ($array[$j] <= $pivot) {
            $i++;
            [$array[$i], $array[$j]] = [$array[$j], $array[$i]];
        }
    }
    [$array[$i + 1], $array[$right]] = [$array[$right], $array[$i + 1]];
    return $i + 1;
}

$array = [3, 1, 2];
quickSort($array, 0, count($array) - 1);
var_dump($array); // [1, 2, 3]
```

### Поиск по массиву

**Бинарный поиск в отсортированном массиве**:
Самый быстрый бинарный поиск применим только после сортировки массива. Стандартные функции (`in_array()`, `array_search()`) не используют бинарный поиск, так как массивы не гарантированно отсортированы => пользовательский бинарный поиск быстрее для больших отсортированных массивов.

```php
function binarySearch($array, $value) {
    $left = 0;
    $right = count($array) - 1;
    while ($left <= $right) {
        $mid = (int)(($left + $right) / 2);
        if ($array[$mid] === $value) {
            return $mid;
        }
        if ($array[$mid] < $value) {
            $left = $mid + 1;
        } else {
            $right = $mid - 1;
        }
    }
    return false;
}

$array = [1, 2, 3, 4, 5];
sort($array); // Необходимо отсортировать
var_dump(binarySearch($array, 3)); // int(2)
```

#### Сравнение производительности
- **Стандартные функции**: Используют introsort (O(n log n) в среднем), оптимизированный на C. Например, `sort()` быстрее пользовательской быстрой сортировки из-за низкоуровневой реализации.
- **Пользовательская быстрая сортировка**: O(n log n) в среднем, но медленнее из-за интерпретируемого кода PHP и накладных расходов на вызовы функций.
- **Бинарный поиск**: O(log n) для поиска в отсортированном массиве, быстрее, чем `array_search()` (O(n)), но требует предварительной сортировки (O(n log n)).

**Тест производительности** (на 10,000 элементов, PHP 8.1):
```php
$array = range(1, 10000);
shuffle($array); // Перемешиваем для реалистичности

$start = microtime(true);
sort($array);
echo "sort: " . (microtime(true) - $start) . " seconds\n";

$array = range(1, 10000);
shuffle($array);
$start = microtime(true);
quickSort($array, 0, count($array) - 1);
echo "quickSort: " . (microtime(true) - $start) . " seconds\n";

$array = range(1, 10000);
sort($array);
$start = microtime(true);
for ($i = 0; $i < 1000; $i++) {
    binarySearch($array, 5000);
}
echo "binarySearch (1000 searches): " . (microtime(true) - $start) . " seconds\n";

$start = microtime(true);
for ($i = 0; $i < 1000; $i++) {
    array_search(5000, $array);
}
echo "array_search (1000 searches): " . (microtime(true) - $start) . " seconds\n";
```
**Примерные результаты** (зависят от окружения):
- `sort`: ~0.002 сек
- `quickSort`: ~0.15 сек
- `binarySearch (1000 searches)`: ~0.001 сек
- `array_search (1000 searches)`: ~0.05 сек

**Выводы**:
- Стандартные функции (`sort()`, `asort()`, и т.д.) значительно быстрее пользовательской сортировки благодаря оптимизации на C.
- Пользовательская быстрая сортировка в PHP медленнее (в ~75 раз в тесте) из-за интерпретируемого кода и накладных расходов.
- Бинарный поиск быстрее `array_search()` для больших отсортированных массивов, но требует предварительной сортировки, что увеличивает общую сложность.

#### Когда использовать
- **Стандартные функции**: Используйте `sort()`, `asort()`, `ksort()` и их варианты для большинства задач, так как они быстрые, стабильные и простые в использовании.
- **Пользовательская сортировка**: Применяйте только в редких случаях, когда требуется специфическая логика, не поддерживаемая `usort()` (например, сложные критерии сравнения).
- **Бинарный поиск**: Полезен для частых поисков в больших отсортированных массивах, но требует предварительной сортировки.

#### Советы для собеседований
- На собеседованиях могут спросить:
    - Разницу между `sort()`, `asort()`, и `ksort()`.
    - Почему `usort()` медленнее `sort()`.
    - Когда стоит использовать бинарный поиск вместо `array_search()`.
    - Как реализовать стабильную сортировку в PHP.


## Обработка ошибок: от @ к исключениям

Ранние версии PHP использовали оператор `@` для подавления ошибок, но в современном коде предпочтительны исключения.

### Ключевые моменты
- **Оператор `@`**: Подавляет ошибки, но делает код менее прозрачным.
  ```php
  $result = @file_get_contents('nonexistent.txt'); // Ошибка подавлена
  var_dump($result); // bool(false)
  ```
- **Исключения**: Позволяют явно обрабатывать ошибки.
  ```php
  try {
      $content = file_get_contents('nonexistent.txt');
  } catch (Exception $e) {
      echo "Ошибка: " . $e->getMessage();
  }
  ```

### Подводные камни
- Использование `@` может скрыть критические ошибки, усложняя отладку.
- В PHP 8 появились новые типы ошибок, такие как `ValueError`.
  ```php
  // PHP 8
  $number = intdiv(10, 0); // ValueError: Division by zero
  ```

**Совет**: Избегайте `@`, используйте `try-catch` и логирование ошибок (например, с Monolog). На собеседованиях могут спросить, почему `@` считается плохой практикой.

## Рекурсия и итерация

Рекурсия — это процесс, при котором функция вызывает саму себя для решения задачи, разбивая её на более мелкие подзадачи. Это мощный инструмент, но он может быть ресурсоёмким и сложным для отладки. Итерация, использующая циклы, часто является альтернативой, которая может быть быстрее и потреблять меньше памяти. Этот раздел разбирает рекурсию, способы её замены и сравнение подходов.

### Что такое рекурсия
Рекурсия в PHP работает, когда функция вызывает себя с новыми параметрами, пока не достигнет базового случая, который завершает выполнение. Каждый вызов создаёт новый кадр в стеке вызовов, что увеличивает потребление памяти.

**Пример: Вычисление факториала (рекурсия)**:
```php
function factorial($n) {
    if ($n <= 1) {
        return 1; // Базовый случай
    }
    return $n * factorial($n - 1); // Рекурсивный вызов
}

var_dump(factorial(5)); // int(120) — 5 * 4 * 3 * 2 * 1
```

**Как это работает**:
- `factorial(5)` вызывает `factorial(4)`, затем `factorial(3)`, и так далее, пока не достигается `factorial(1)`.
- Стек вызовов растёт: `[factorial(5), factorial(4), factorial(3), ...]`.
- После достижения базового случая стек разворачивается, вычисляя результат.

**Пример: Обход дерева (рекурсия)**:
```php
function traverseTree($node) {
    if ($node === null) {
        return; // Базовый случай
    }
    echo $node['value'] . "\n";
    traverseTree($node['left']); // Рекурсия для левого поддерева
    traverseTree($node['right']); // Рекурсия для правого поддерева
}

$tree = [
    'value' => 1,
    'left' => ['value' => 2, 'left' => null, 'right' => null],
    'right' => ['value' => 3, 'left' => null, 'right' => null]
];
traverseTree($tree); // Вывод: 1, 2, 3
```

### Переписывание рекурсии в итерацию
Рекурсию можно заменить итерацией, используя циклы (`while`, `for`) и, при необходимости, стек для имитации стека вызовов. Это снижает потребление памяти, так как не создаются новые кадры в стеке.

#### Факториал (итерация)
```php
function factorialIterative($n) {
    $result = 1;
    for ($i = 1; $i <= $n; $i++) {
        $result *= $i;
    }
    return $result;
}

var_dump(factorialIterative(5)); // int(120)
```

**Как это работает**:
- Вместо рекурсивных вызовов используется цикл, накапливающий результат.
- Нет дополнительных кадров в стеке, только одна переменная `$result`.

#### Обход дерева (итерация с использованием стека)
```php
function traverseTreeIterative($root) {
    if ($root === null) {
        return;
    }
    $stack = [$root];
    while (!empty($stack)) {
        $node = array_pop($stack);
        echo $node['value'] . "\n";
        // Добавляем правое поддерево первым, чтобы левое обработалось раньше
        if ($node['right'] !== null) {
            $stack[] = $node['right'];
        }
        if ($node['left'] !== null) {
            $stack[] = $node['left'];
        }
    }
}

traverseTreeIterative($tree); // Вывод: 1, 2, 3
```

**Как это работает**:
- Стек (`$stack`) имитирует стек вызовов, сохраняя узлы для обработки.
- Узлы извлекаются из стека, а их поддеревья добавляются в порядке, обеспечивающем тот же порядок обхода (префиксный).
- Память используется только для стека, а не для кадров вызовов.

### Анализ рекурсии и итерации

#### Производительность
- **Рекурсия**:
    - **Плюсы**: Код часто короче и читаемее, особенно для задач, таких как обход дерева или рекурсивные алгоритмы (например, обход графа).
    - **Минусы**: Каждый вызов создаёт кадр в стеке, увеличивая потребление памяти (O(n) для глубины рекурсии). Глубокая рекурсия может вызвать переполнение стека (`Fatal error: Maximum function nesting level`).
    - Пример: Для `factorial(10000)` рекурсия может исчерпать стек на некоторых системах.
- **Итерация**:
    - **Плюсы**: Не создаёт новых кадров, потребляет меньше памяти (O(1) для простых случаев, O(n) для стека при имитации рекурсии). Обычно быстрее из-за отсутствия накладных расходов на вызовы функций.
    - **Минусы**: Код может быть сложнее и менее интуитивным, особенно для древовидных структур.

**Тест производительности** (на 10,000 итераций, PHP 8.1):
```php
$n = 20;
$iterations = 10000;

// Рекурсивный факториал
$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    factorial($n);
}
echo "factorial (recursive): " . (microtime(true) - $start) . " seconds\n";

// Итеративный факториал
$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    factorialIterative($n);
}
echo "factorial (iterative): " . (microtime(true) - $start) . " seconds\n";

// Рекурсивный обход дерева
$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    traverseTree($tree);
}
echo "traverseTree (recursive): " . (microtime(true) - $start) . " seconds\n";

// Итеративный обход дерева
$start = microtime(true);
for ($i = 0; $i < $iterations; $i++) {
    traverseTreeIterative($tree);
}
echo "traverseTree (iterative): " . (microtime(true) - $start) . " seconds\n";
```
**Примерные результаты** (зависят от окружения):
- `factorial (recursive)`: ~0.08 сек
- `factorial (iterative)`: ~0.03 сек
- `traverseTree (recursive)`: ~0.06 сек
- `traverseTree (iterative)`: ~0.05 сек

**Выводы**:
- Итеративный факториал значительно быстрее (~2.5 раза) из-за отсутствия накладных расходов на вызовы.
- Итеративный обход дерева немного быстрее (~1.2 раза), но разница меньше из-за необходимости управления стеком.
- Для больших входных данных рекурсия может привести к переполнению стека, тогда как итерация более устойчива.

#### Подводные камни
- **Рекурсия**:
    - **Переполнение стека**: Глубокая рекурсия (например, `factorial(100000)`) может вызвать ошибку.
      ```php
      factorial(100000); // Fatal error: Maximum function nesting level
      ```
    - **Хвостовая рекурсия**: PHP не оптимизирует хвостовую рекурсию, в отличие от некоторых языков (например, JavaScript с ES6). Это увеличивает потребление памяти.
      ```php
      function factorialTail($n, $acc = 1) {
          if ($n <= 1) {
              return $acc;
          }
          return factorialTail($n - 1, $n * $acc);
      }
      // Всё равно создаёт стек вызовов
      ```
- **Итерация**:
    - **Сложность кода**: Итеративные решения для сложных задач, таких как обход дерева, могут быть громоздкими.
    - **Ошибки в управлении стеком**: Неправильная работа со стеком (например, неверный порядок добавления узлов) может нарушить логику.
      ```php
      // Ошибка: Неверный порядок добавления в стек
      $stack[] = $node['left'];
      $stack[] = $node['right']; // Поменяет порядок обхода
      ```

#### Когда использовать
- **Рекурсия**:
    - Когда задача естественно рекурсивна (например, обход дерева, графов, рекурсивные алгоритмы, такие как быстрая сортировка).
    - Когда читаемость важнее производительности, а входные данные ограничены.
    - Пример: Обход файловой системы.
      ```php
      function scanDirRecursive($dir) {
          if (!is_dir($dir)) {
              return;
          }
          echo $dir . "\n";
          foreach (scandir($dir) as $file) {
              if ($file !== '.' && $file !== '..') {
                  scanDirRecursive($dir . '/' . $file);
              }
          }
      }
      ```
- **Итерация**:
    - Когда важна производительность или входные данные могут быть большими.
    - Когда нужно избежать переполнения стека.
    - Пример: Суммирование элементов массива.
      ```php
      function arraySum($array) {
          $sum = 0;
          foreach ($array as $value) {
              $sum += $value;
          }
          return $sum;
      }
      ```

### Советы для собеседований
- На собеседованиях часто спрашивают:
    - Что такое рекурсия и как она работает в PHP.
    - Как переписать рекурсивный код в итеративный (например, факториал, обход дерева).
    - Почему рекурсия может привести к переполнению стека и как этого избежать.
    - Разницу в производительности между рекурсией и итерацией.
- Подготовьтесь объяснить, как стек вызовов влияет на память и как итерация с использованием стека может заменить рекурсию.
- Практикуйтесь с задачами, такими как вычисление чисел Фибоначчи или обход дерева, в обоих подходах.


## Типичные вопросы на собеседованиях о коде PHP

Вот несколько типичных вопросов по основам PHP, которые встречаются на собеседованиях, с ответами:

1. **Что выведет этот код?**
   ```php
   $a = 5;
   $b = "5";
   var_dump($a == $b, $a === $b);
   ```
   **Ответ**: `bool(true), bool(false)` — `==` приводит типы, `===` проверяет типы.

2. **Почему этот код вызовет ошибку?**
   ```php
   function test($a, $b = 10) {
       echo $a + $b;
   }
   test();
   ```
   **Ответ**: Fatal error, так как параметр `$a` обязателен, а `$b` — необязательный.

3. **Что выведет этот код?**
   ```php
   $array = [1, 2, 3];
   unset($array[1]);
   var_dump(array_values($array));
   ```
   **Ответ**: `[0 => 1, 1 => 3]` — `unset` удаляет элемент, а `array_values` переиндексирует массив.

4. **Как работает замыкание в этом коде?**
   ```php
   $x = 10;
   $closure = function() use ($x) {
       return $x;
   };
   $x = 20;
   echo $closure();
   ```
   **Ответ**: `10` — замыкание захватывает значение `$x` на момент создания.

**Совет**: Практикуйтесь с подобными вопросами, чтобы уверенно отвечать на собеседованиях. Используйте песочницы вроде 3v4l.org для проверки кода.